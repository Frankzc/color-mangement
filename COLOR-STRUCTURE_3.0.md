## ğŸ¯ æ€»ç»“

æœ¬æ–‡æ¡£æä¾›äº†åŸºäºæ‚¨å®é™…æºæ–‡ä»¶çš„ç®€åŒ–é¢œè‰²æ•°æ®ç»“æ„è®¾è®¡ï¼ŒåŒ…æ‹¬ï¼š

### ğŸ—ï¸ æ ¸å¿ƒæ¶æ„ï¼ˆç®€åŒ–ç‰ˆï¼‰
- **åŒè¡¨è®¾è®¡**ï¼šä¸»é¢œè‰²è¡¨ + ç®€åŒ–çš„æ–‡åŒ–æè¿°è¡¨
- **æ€§èƒ½ä¼˜å…ˆ**ï¼šæ‡’åŠ è½½ + åŸºç¡€ç¼“å­˜
- **æºæ–‡ä»¶é€‚é…**ï¼šç›´æ¥åŸºäºæ‚¨çš„JSONæ ¼å¼è®¾è®¡
- **ç®—æ³•åˆ†ç±»**ï¼šåŸºç¡€åˆ†ç±»é€šè¿‡ç®—æ³•è‡ªåŠ¨ç”Ÿæˆ

### ğŸ“Š æ•°æ®ç‰¹æ€§ï¼ˆç®€åŒ–ç‰ˆï¼‰
- **åŸºç¡€å®Œæ•´**ï¼šåŒ…å«RGBã€HSLç­‰åŸºæœ¬è‰²å½©æ•°æ®
- **æ–‡åŒ–æ”¯æŒ**ï¼šåŸºäºæ‚¨çš„æºæ–‡ä»¶ç»“æ„è®¾è®¡
- **æœç´¢ä¼˜åŒ–**ï¼šåŸºç¡€æœç´¢å…³é”®è¯ç”Ÿæˆ
- **æ‰©å±•é¢„ç•™**ï¼šä¸ºæœªæ¥åŠŸèƒ½é¢„ç•™ç©ºé—´

### ğŸ”§ æŠ€æœ¯å®ç°ï¼ˆå®ç”¨ç‰ˆï¼‰
- **æ•°æ®å¯¼å…¥**ï¼šåŸºäºæ‚¨çš„æºæ–‡ä»¶è‡ªåŠ¨å¯¼å…¥è„šæœ¬
- **APIè®¾è®¡**ï¼šç®€åŒ–çš„RESTfulæ¥å£
- **å‰ç«¯ç»„ä»¶**ï¼šå®ç”¨çš„Vue3ç»„ä»¶
- **åˆ†ç±»ç®—æ³•**ï¼šè‡ªåŠ¨åŒ–çš„åŸºç¡€åˆ†ç±»

### ğŸ›¡ï¸ è¿ç»´ä¿éšœï¼ˆåŸºç¡€ç‰ˆï¼‰
- **æ•°æ®å¯¼å…¥**ï¼šè‡ªåŠ¨åŒ–å¯¼å…¥è„šæœ¬
- **åŸºç¡€ç¼“å­˜**ï¼šRedisåŸºç¡€ç¼“å­˜ç­–ç•¥
- **é”™è¯¯å¤„ç†**ï¼šåŸºæœ¬çš„é”™è¯¯å¤„ç†æœºåˆ¶
- **æ‰©å±•è®¡åˆ’**ï¼šæ˜ç¡®çš„åæœŸæ‰©å±•è·¯å¾„

### ğŸ“‹ å…³é”®ç®€åŒ–ç‚¹
1. **æ–‡åŒ–æè¿°è¡¨ç®€åŒ–**ï¼šåªä¿ç•™æ ¸å¿ƒå­—æ®µï¼ˆoriginal_name + descriptionï¼‰
2. **åˆ†ç±»ç³»ç»Ÿç®€åŒ–**ï¼šç§»é™¤å¤æ‚çš„æ–‡åŒ–æ ‡ç­¾ï¼Œä¸“æ³¨åŸºç¡€åˆ†ç±»
3. **ç®—æ³•é©±åŠ¨**ï¼šseasonsã€scenesã€moodsã€stylesé€šè¿‡ç®—æ³•è‡ªåŠ¨ç”Ÿæˆ
4. **æºæ–‡ä»¶é€‚é…**ï¼šç›´æ¥ä½¿ç”¨æ‚¨ç°æœ‰çš„nameã€hexã€descå­—æ®µ# Fashion Color å®Œæ•´é¢œè‰²æ•°æ®ç»“æ„è®¾è®¡æ–‡æ¡£

## ğŸ“‹ æ–‡æ¡£æ¦‚è§ˆ

**ç‰ˆæœ¬**: v3.0  
**æ›´æ–°æ—¥æœŸ**: 2025å¹´9æœˆ10æ—¥  
**è®¾è®¡åŸåˆ™**: æ€§èƒ½ä¼˜å…ˆ + åŠŸèƒ½å®Œæ•´ + æ‰©å±•çµæ´»  

## ğŸ¯ æ ¸å¿ƒè®¾è®¡ç†å¿µ

### è®¾è®¡ç›®æ ‡
1. **é«˜æ€§èƒ½**: é¢œè‰²åˆ—è¡¨åŠ è½½å¿«é€Ÿï¼Œæ–‡åŒ–æè¿°æŒ‰éœ€åŠ è½½
2. **å¤šæ–‡åŒ–**: æ”¯æŒä¸€ä¸ªé¢œè‰²çš„å¤šç§æ–‡åŒ–èƒŒæ™¯æè¿°
3. **å¯æ‰©å±•**: ä¾¿äºåæœŸæ·»åŠ æ–°åŠŸèƒ½å’Œæ–°æ–‡åŒ–
4. **æ˜“ç»´æŠ¤**: æ•°æ®ç»“æ„æ¸…æ™°ï¼Œç»´æŠ¤æˆæœ¬ä½

### æ¶æ„ç­–ç•¥
- **ä¸»ä»åˆ†ç¦»**: åŸºç¡€é¢œè‰²ä¿¡æ¯ + æ‰©å±•æ–‡åŒ–æè¿°
- **æ‡’åŠ è½½**: æ–‡åŒ–æè¿°ä¿¡æ¯æŒ‰éœ€åŠ è½½
- **ç¼“å­˜ä¼˜åŒ–**: å‰åç«¯åŒé‡ç¼“å­˜æœºåˆ¶
- **åˆ†ç±»ç®€åŒ–**: è§£å†³åŸæœ‰æ ‡ç­¾é‡åˆé—®é¢˜

## ğŸ“Š æ•°æ®è¡¨è®¾è®¡

### 1. ä¸»é¢œè‰²è¡¨ (colors)

```sql
CREATE TABLE colors (
  -- ğŸ”‘ åŸºç¡€æ ‡è¯†
  id VARCHAR(20) PRIMARY KEY,                    -- å¦‚: color_0001
  source VARCHAR(30) NOT NULL,                   -- æ•°æ®æ¥æº: chinese_traditional|japanese|indian|western|modern
  priority TINYINT DEFAULT 2,                    -- ä¼˜å…ˆçº§: 1=ç°ä»£è‰² 2=ä¼ ç»Ÿè‰² 3=åˆæˆè‰²
  status ENUM('active','inactive','deprecated') DEFAULT 'active',
  
  -- ğŸŒˆ é¢œè‰²æ•°å€¼
  hex CHAR(7) NOT NULL,                          -- #DC143C
  rgb_r TINYINT UNSIGNED NOT NULL,               -- 0-255
  rgb_g TINYINT UNSIGNED NOT NULL,               -- 0-255
  rgb_b TINYINT UNSIGNED NOT NULL,               -- 0-255
  hsl_h SMALLINT UNSIGNED,                       -- 0-360
  hsl_s TINYINT UNSIGNED,                        -- 0-100
  hsl_l TINYINT UNSIGNED,                        -- 0-100
  
  -- ğŸ“ åŸºç¡€å‘½å
  name_zh VARCHAR(50) NOT NULL,                  -- ä¸­å›½çº¢
  name_en VARCHAR(50),                           -- Chinese Red
  name_ja VARCHAR(50),                           -- ä¸­å›½ã®èµ¤
  aliases JSON,                                  -- ["æ·±çº¢","æœ±çº¢","çŒ©çº¢"]
  
  -- ğŸ›ï¸ æ–‡åŒ–å½’å±ï¼ˆç®€åŒ–ç‰ˆï¼‰
  primary_culture ENUM('chinese','japanese','indian','western','mexican','other'),
  cultural_tags JSON,                            -- ["ch_tr","in_hi"] æ”¯æŒå¤šæ–‡åŒ–æ ‡ç­¾
  has_cultural_description BOOLEAN DEFAULT FALSE, -- ğŸ”‘ æ˜¯å¦æœ‰è¯¦ç»†æ–‡åŒ–æè¿°
  
  -- ğŸ¨ åˆ†ç±»æ ‡ç­¾ï¼ˆä¼˜åŒ–åçš„åˆ†ç±»ä½“ç³»ï¼‰
  seasons JSON,                                  -- ["au","wi"] å­£èŠ‚
  scenes JSON,                                   -- ["ce","fe","fo"] åœºæ™¯
  moods JSON,                                    -- ["sa","wa","vi"] æƒ…æ„Ÿ
  styles JSON,                                   -- ["tr","lu"] é£æ ¼
  religious_contexts JSON,                       -- ["hi","ta"] å®—æ•™è¯­å¢ƒ
  symbolic_categories JSON,                      -- ["sp","ro","fe"] è±¡å¾ç±»åˆ«
  fashion_contexts JSON,                         -- ["tw","fw"] æ—¶è£…è¯­å¢ƒ
  
  -- ğŸ“Š è®¡ç®—å±æ€§ï¼ˆå¯é¢„è®¡ç®—å­˜å‚¨ä»¥æå‡æ€§èƒ½ï¼‰
  brightness TINYINT UNSIGNED,                   -- äº®åº¦å€¼ 0-255
  warmth TINYINT,                                -- è‰²æ¸© -100åˆ°100
  saturation TINYINT UNSIGNED,                   -- é¥±å’Œåº¦ 0-100
  contrast_ratio DECIMAL(3,2),                   -- å¯¹æ¯”åº¦
  
  -- ğŸ” æœç´¢ä¼˜åŒ–
  search_keywords TEXT,                          -- æœç´¢å…³é”®è¯ï¼Œç©ºæ ¼åˆ†éš”
  search_boost DECIMAL(3,2) DEFAULT 1.0,        -- æœç´¢æƒé‡
  
  -- ğŸ“ˆ ç»Ÿè®¡ä¿¡æ¯
  view_count INT DEFAULT 0,                      -- æŸ¥çœ‹æ¬¡æ•°
  favorite_count INT DEFAULT 0,                 -- æ”¶è—æ¬¡æ•°
  popularity_score DECIMAL(3,2) DEFAULT 0,      -- çƒ­é—¨åº¦è¯„åˆ†
  
  -- ğŸ—‚ï¸ ç³»ç»Ÿç®¡ç†
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  created_by VARCHAR(50) DEFAULT 'system',
  quality_score DECIMAL(3,2) DEFAULT 1.0,       -- æ•°æ®è´¨é‡è¯„åˆ†
  
  -- ç´¢å¼•
  INDEX idx_hex (hex),
  INDEX idx_primary_culture (primary_culture),
  INDEX idx_status (status),
  INDEX idx_popularity (popularity_score DESC),
  INDEX idx_search (search_boost DESC, popularity_score DESC),
  FULLTEXT idx_keywords (search_keywords)
);
```

### 2. æ–‡åŒ–æè¿°è¡¨ (color_cultural_descriptions)

```sql
CREATE TABLE color_cultural_descriptions (
  -- ğŸ”‘ åŸºç¡€æ ‡è¯†
  id VARCHAR(30) PRIMARY KEY,                    -- å¦‚: desc_0001
  color_id VARCHAR(20) NOT NULL,                 -- å…³è”colorsè¡¨
  culture ENUM('chinese','japanese','indian','western','mexican','african','latin','middle_eastern','other'),
  cultural_tag VARCHAR(10),                      -- å…·ä½“æ–‡åŒ–æ ‡ç­¾: ch_tr, jp_zeç­‰
  priority TINYINT DEFAULT 1,                    -- æ˜¾ç¤ºä¼˜å…ˆçº§ï¼Œæ•°å­—è¶Šå°è¶Šä¼˜å…ˆ
  
  -- ğŸ¨ æ ¸å¿ƒæè¿°å†…å®¹
  description_zh TEXT,                           -- ä¸­æ–‡æè¿°
  description_en TEXT,                           -- è‹±æ–‡æè¿°
  short_description_zh VARCHAR(200),             -- ç®€çŸ­æè¿°ï¼ˆç”¨äºé¢„è§ˆï¼‰
  short_description_en VARCHAR(200),
  
  -- ğŸ“œ å†å²æ–‡åŒ–ä¿¡æ¯
  historical_story_zh TEXT,                      -- å†å²æ•…äº‹
  historical_story_en TEXT,
  historical_period VARCHAR(50),                 -- å†å²æ—¶æœŸ: å¤ä»£|è¿‘ä»£|ç°ä»£
  cultural_significance DECIMAL(3,2),            -- æ–‡åŒ–é‡è¦æ€§ 0-1
  
  -- ğŸ­ ä¼ ç»Ÿåº”ç”¨åœºæ™¯
  traditional_usage JSON,                        -- [{"scene":"wedding","description_zh":"...","description_en":"..."}]
  modern_significance_zh TEXT,                   -- ç°ä»£æ„ä¹‰
  modern_significance_en TEXT,
  
  -- ğŸ¨ é…è‰²å»ºè®®
  cultural_pairing JSON,                         -- [{"color":"#FFD700","name":"é‡‘é»„","reason_zh":"...","reason_en":"..."}]
  symbolic_meanings JSON,                        -- ["purity","blessing","prosperity"]
  
  -- ğŸ“š å‚è€ƒèµ„æ–™
  references JSON,                               -- ["ã€Šä¸­å›½ä¼ ç»Ÿè‰²å½©ç ”ç©¶ã€‹","Traditional Chinese Colors"]
  image_references JSON,                         -- ["palace_red.jpg","traditional_art.jpg"]
  
  -- ğŸ—‚ï¸ ç³»ç»Ÿç®¡ç†
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  created_by VARCHAR(50),
  verified_by VARCHAR(50),                       -- æ–‡åŒ–ä¸“å®¶éªŒè¯
  verification_date TIMESTAMP,
  quality_score DECIMAL(3,2) DEFAULT 1.0,
  
  -- å¤–é”®å’Œç´¢å¼•
  FOREIGN KEY (color_id) REFERENCES colors(id) ON DELETE CASCADE,
  INDEX idx_color_culture (color_id, culture),
  INDEX idx_priority (color_id, priority),
  INDEX idx_culture (culture),
  INDEX idx_verification (verified_by, verification_date)
);
```

### 3. åˆ†ç±»å­—å…¸è¡¨ (classification_dictionaries)

```sql
CREATE TABLE classification_dictionaries (
  id VARCHAR(20) PRIMARY KEY,
  category ENUM('cultures','seasons','scenes','moods','styles','cultural_tags','religious_contexts','symbolic_categories','fashion_contexts','texture_associations'),
  code VARCHAR(10) NOT NULL,                     -- å¦‚: ch, sp, ce
  name_zh VARCHAR(50) NOT NULL,                  -- ä¸­æ–‡åç§°
  name_en VARCHAR(50),                           -- è‹±æ–‡åç§°
  description_zh TEXT,                           -- è¯¦ç»†æè¿°
  description_en TEXT,
  sort_order INT DEFAULT 0,                      -- æ’åºé¡ºåº
  is_active BOOLEAN DEFAULT TRUE,
  
  UNIQUE KEY uk_category_code (category, code),
  INDEX idx_category (category, sort_order)
);
```

## ğŸ¨ JSONå­—æ®µè¯¦ç»†ç»“æ„

### 1. ä¸»é¢œè‰²è¡¨JSONå­—æ®µ

#### aliases (åˆ«åæ•°ç»„)
```json
["æ·±çº¢", "æœ±çº¢", "çŒ©çº¢", "crimson", "scarlet"]
```

#### cultural_tags (æ–‡åŒ–æ ‡ç­¾æ•°ç»„)
```json
["ch_tr", "in_hi"]  // ä¸­å›½ä¼ ç»Ÿ + å°åº¦æ•™
```

#### seasons (å­£èŠ‚æ•°ç»„)
```json
["au", "wi"]  // ç§‹å­£ã€å†¬å­£
```

#### scenes (åœºæ™¯æ•°ç»„)
```json
["ce", "fe", "fo"]  // ä»ªå¼ã€èŠ‚åº†ã€æ­£å¼
```

#### moods (æƒ…æ„Ÿæ•°ç»„)
```json
["sa", "wa", "vi"]  // ç¥åœ£ã€æ¸©æš–ã€æ´»åŠ›
```

#### styles (é£æ ¼æ•°ç»„)
```json
["tr", "lu"]  // ä¼ ç»Ÿã€å¥¢å
```

#### religious_contexts (å®—æ•™è¯­å¢ƒæ•°ç»„)
```json
["hi", "ta"]  // å°åº¦æ•™ã€é“æ•™
```

#### symbolic_categories (è±¡å¾ç±»åˆ«æ•°ç»„)
```json
["sp", "ro", "fe"]  // ç²¾ç¥æ€§ã€çš‡å®¤æ€§ã€èŠ‚åº†æ€§
```

#### fashion_contexts (æ—¶è£…è¯­å¢ƒæ•°ç»„)
```json
["tw", "fw"]  // ä¼ ç»Ÿæœé¥°ã€æ­£è£…
```

### 2. æ–‡åŒ–æè¿°è¡¨JSONå­—æ®µ

#### traditional_usage (ä¼ ç»Ÿåº”ç”¨)
```json
[
  {
    "scene": "wedding",
    "description_zh": "æ–°å¨˜çš„å«è¡£ã€çº¢ç›–å¤´ï¼Œå¯“æ„çº¢çº¢ç«ç«",
    "description_en": "Bride's wedding dress and red veil, symbolizing prosperity"
  },
  {
    "scene": "festival", 
    "description_zh": "æ˜¥èŠ‚çº¢ç¯ç¬¼ã€å¯¹è”ï¼Œè¥é€ å–œåº†æ°›å›´",
    "description_en": "Spring Festival red lanterns and couplets create festive atmosphere"
  }
]
```

#### cultural_pairing (æ–‡åŒ–é…è‰²)
```json
[
  {
    "color": "#FFD700",
    "name_zh": "é‡‘é»„",
    "name_en": "Gold",
    "reason_zh": "çº¢é‡‘æ­é…ï¼Œå¯Œè´µå‰ç¥¥",
    "reason_en": "Red and gold pairing symbolizes wealth and fortune"
  },
  {
    "color": "#FFFFFF",
    "name_zh": "çº¯ç™½", 
    "name_en": "Pure White",
    "reason_zh": "çº¢ç™½å¯¹æ¯”ï¼Œåº„é‡å…¸é›…",
    "reason_en": "Red and white contrast creates solemnity and elegance"
  }
]
```

#### symbolic_meanings (è±¡å¾æ„ä¹‰)
```json
["prosperity", "protection", "joy", "strength", "passion"]
```

#### references (å‚è€ƒèµ„æ–™)
```json
[
  "ã€Šä¸­å›½ä¼ ç»Ÿè‰²å½©æ–‡åŒ–ç ”ç©¶ã€‹- ææ˜å",
  "Traditional Chinese Color Culture Research - Li Minghua",
  "ã€Šè‰²å½©çš„æ–‡åŒ–å†…æ¶µã€‹- ç‹æ™“çº¢"
]
```

#### image_references (å›¾ç‰‡å‚è€ƒ)
```json
[
  "chinese_red_palace.jpg",
  "traditional_wedding_dress.jpg",
  "spring_festival_decorations.jpg"
]
```

## ğŸ“ åˆ†ç±»å­—å…¸æ•°æ®

### åŸºç¡€æ–‡åŒ–åˆ†ç±»
```json
{
  "cultures": {
    "c": "chinese",
    "j": "japanese", 
    "i": "indian",
    "w": "western",
    "m": "mexican"
  }
}
```

### æ–‡åŒ–æ ‡ç­¾ï¼ˆæ–°å¢ï¼Œè§£å†³é‡åˆé—®é¢˜ï¼‰
```json
{
  "cultural_tags": {
    "ch_tr": "chinese_traditional",     // ä¸­å›½ä¼ ç»Ÿ
    "ch_mo": "chinese_modern",          // ä¸­å›½ç°ä»£
    "jp_tr": "japanese_traditional",    // æ—¥æœ¬ä¼ ç»Ÿ
    "jp_ze": "japanese_zen",            // æ—¥æœ¬ç¦…æ„
    "jp_wa": "japanese_wabi_sabi",      // æ—¥æœ¬ä¾˜å¯‚
    "in_tr": "indian_traditional",      // å°åº¦ä¼ ç»Ÿ
    "in_ay": "indian_ayurveda",         // å°åº¦é˜¿è‚²å é™€
    "in_hi": "indian_hindu",            // å°åº¦æ•™
    "we_cl": "western_classical",       // è¥¿æ–¹å¤å…¸
    "we_mo": "western_modern",          // è¥¿æ–¹ç°ä»£
    "me_tr": "mediterranean",           // åœ°ä¸­æµ·é£æƒ…
    "af_ea": "african_earth",           // éæ´²å¤§åœ°
    "la_vi": "latin_vibrant"            // æ‹‰ä¸æ´»åŠ›
  }
}
```

### å­£èŠ‚åˆ†ç±»
```json
{
  "seasons": {
    "sp": "spring",
    "su": "summer", 
    "au": "autumn",
    "wi": "winter"
  }
}
```

### åœºæ™¯åˆ†ç±»
```json
{
  "scenes": {
    "ce": "ceremonial",     // ä»ªå¼åœºåˆ
    "fe": "festive",        // èŠ‚åº†åœºåˆ
    "ca": "casual",         // æ—¥å¸¸ä¼‘é—²
    "fo": "formal",         // æ­£å¼åœºåˆ
    "me": "meditative",     // å†¥æƒ³é™ä¿®
    "we": "wedding",        // å©šç¤¼åº†å…¸
    "bu": "business"        // å•†åŠ¡åœºåˆ
  }
}
```

### æƒ…æ„Ÿæ°›å›´
```json
{
  "moods": {
    "sa": "sacred",         // ç¥åœ£åº„ä¸¥
    "wa": "warm",           // æ¸©æš–äº²å’Œ
    "vi": "vibrant",        // æ´»åŠ›å››å°„
    "ca": "calm",           // å¹³é™å®‰è¯¦
    "el": "elegant",        // ä¼˜é›…ç²¾è‡´
    "my": "mysterious",     // ç¥ç§˜æ·±é‚ƒ
    "jo": "joyful",         // æ¬¢å¿«æ„‰æ‚¦
    "so": "sophisticated"   // ç²¾è‡´å¤å¤
  }
}
```

### è®¾è®¡é£æ ¼
```json
{
  "styles": {
    "tr": "traditional",    // ä¼ ç»Ÿå¤å…¸
    "mo": "modern",         // ç°ä»£ç®€çº¦
    "mi": "minimalist",     // æç®€ä¸»ä¹‰
    "lu": "luxury",         // å¥¢åé«˜ç«¯
    "vi": "vintage",        // å¤å¤æ€€æ—§
    "bo": "bohemian",       // æ³¢å¸Œç±³äºš
    "in": "industrial",     // å·¥ä¸šé£æ ¼
    "ru": "rustic"          // ä¹¡æ‘ç”°å›­
  }
}
```

### å®—æ•™è¯­å¢ƒ
```json
{
  "religious_contexts": {
    "hi": "hindu",          // å°åº¦æ•™
    "bu": "buddhist",       // ä½›æ•™
    "is": "islamic",        // ä¼Šæ–¯å…°æ•™
    "ch": "christian",      // åŸºç£æ•™
    "ju": "jewish",         // çŠ¹å¤ªæ•™
    "ta": "taoist",         // é“æ•™
    "sh": "shinto",         // ç¥é“æ•™
    "si": "sikh",           // é”¡å…‹æ•™
    "ja": "jainism",        // è€†é‚£æ•™
    "zo": "zoroastrian"     // çç½—äºšæ–¯å¾·æ•™
  }
}
```

### è±¡å¾ç±»åˆ«
```json
{
  "symbolic_categories": {
    "sp": "spiritual",      // ç²¾ç¥æ€§ï¼ˆç¥åœ£ã€å†¥æƒ³ã€å®—æ•™ï¼‰
    "na": "natural",        // è‡ªç„¶æ€§ï¼ˆå¤§åœ°ã€æ¤ç‰©ã€å¤©ç©ºï¼‰
    "ro": "royal",          // çš‡å®¤æ€§ï¼ˆæƒåŠ›ã€å¨ä¸¥ã€å¥¢åï¼‰
    "fe": "festive",        // èŠ‚åº†æ€§ï¼ˆåº†ç¥ã€æ¬¢ä¹ã€å‰ç¥¥ï¼‰
    "he": "healing",        // æ²»æ„ˆæ€§ï¼ˆå¹³é™ã€å¥åº·ã€æ¢å¤ï¼‰
    "pr": "protective",     // ä¿æŠ¤æ€§ï¼ˆå®‰å…¨ã€é˜²æŠ¤ã€å®ˆæŠ¤ï¼‰
    "tr": "transformative", // è½¬åŒ–æ€§ï¼ˆå˜åŒ–ã€æˆé•¿ã€é‡ç”Ÿï¼‰
    "co": "communicative",  // äº¤æµæ€§ï¼ˆç¤¾äº¤ã€è¡¨è¾¾ã€è¿æ¥ï¼‰
    "ab": "abundance",      // ä¸°ç››æ€§ï¼ˆå¯Œè¶³ã€ç¹è£ã€æˆåŠŸï¼‰
    "wi": "wisdom"          // æ™ºæ…§æ€§ï¼ˆçŸ¥è¯†ã€å¯å‘ã€æ´å¯Ÿï¼‰
  }
}
```

### æ—¶è£…è¯­å¢ƒ
```json
{
  "fashion_contexts": {
    "tw": "traditional_wear", // ä¼ ç»Ÿæœé¥°
    "cd": "casual_daily",     // æ—¥å¸¸ä¼‘é—²
    "fw": "formal_wear",      // æ­£è£…åœºåˆ
    "ew": "evening_wear",     // æ™šè£…åœºåˆ
    "sw": "sportswear",       // è¿åŠ¨è£…
    "br": "bridal_wear",      // æ–°å¨˜è£…
    "fv": "festival_wear",    // èŠ‚åº†è£…
    "bw": "business_wear"     // å•†åŠ¡è£…
  }
}
```

## ğŸ’¾ ç¤ºä¾‹æ•°æ®è®°å½•

### 1. ä¸»é¢œè‰²è®°å½•ç¤ºä¾‹
```json
{
  "id": "color_0001",
  "source": "chinese_traditional",
  "priority": 2,
  "status": "active",
  
  "hex": "#DC143C",
  "rgb_r": 220,
  "rgb_g": 20,
  "rgb_b": 60,
  "hsl_h": 348,
  "hsl_s": 83,
  "hsl_l": 47,
  
  "name_zh": "ä¸­å›½çº¢",
  "name_en": "Chinese Red",
  "name_ja": "ä¸­å›½ã®èµ¤",
  "aliases": ["æ·±çº¢", "æœ±çº¢", "çŒ©çº¢", "crimson"],
  
  "primary_culture": "chinese",
  "cultural_tags": ["ch_tr"],
  "has_cultural_description": true,
  
  "seasons": ["au", "wi"],
  "scenes": ["ce", "fe", "fo"],
  "moods": ["sa", "wa", "vi"],
  "styles": ["tr", "lu"],
  "religious_contexts": ["ta"],
  "symbolic_categories": ["sp", "ro", "fe"],
  "fashion_contexts": ["tw", "fw"],
  
  "brightness": 74,
  "warmth": 85,
  "saturation": 83,
  "contrast_ratio": 0.65,
  
  "search_keywords": "çº¢è‰² ä¸­å›½ ä¼ ç»Ÿ èŠ‚åº† å©šç¤¼ æ­£è£… red chinese traditional formal wedding",
  "search_boost": 1.5,
  
  "view_count": 1250,
  "favorite_count": 45,
  "popularity_score": 0.85,
  
  "created_at": "2025-09-10T00:00:00Z",
  "updated_at": "2025-09-10T12:00:00Z",
  "created_by": "admin",
  "quality_score": 0.95
}
```

### 2. æ–‡åŒ–æè¿°è®°å½•ç¤ºä¾‹
```json
{
  "id": "desc_0001",
  "color_id": "color_0001",
  "culture": "chinese",
  "cultural_tag": "ch_tr",
  "priority": 1,
  
  "description_zh": "ä¸­å›½çº¢æ˜¯ä¸­åæ–‡åŒ–ä¸­æœ€å…·ä»£è¡¨æ€§çš„é¢œè‰²ï¼Œè±¡å¾ç€å‰ç¥¥ã€å–œåº†ã€å°Šè´µä¸åŠ›é‡ã€‚åœ¨ä¼ ç»Ÿæ–‡åŒ–ä¸­ï¼Œçº¢è‰²è¢«è®¤ä¸ºèƒ½å¤Ÿé©±é‚ªé¿å‡¶ï¼Œå¸¦æ¥å¥½è¿ã€‚ä»å¤ä»£çš‡å®¤çš„æœ±ç ‚å°ç« åˆ°ç°ä»£æ˜¥èŠ‚çš„çº¢ç¯ç¬¼ï¼Œè¿™ç§æ·±æ²‰è€Œçƒ­çƒˆçš„çº¢è‰²æ‰¿è½½ç€æ·±åšçš„æ–‡åŒ–åº•è•´ã€‚",
  
  "description_en": "Chinese Red is the most representative color in Chinese culture, symbolizing auspiciousness, celebration, nobility and power. In traditional culture, red is believed to ward off evil and bring good luck. From ancient royal cinnabar seals to modern Spring Festival red lanterns, this deep and warm red carries profound cultural heritage.",
  
  "short_description_zh": "ä¸­åæ–‡åŒ–ä¸­æœ€å…·ä»£è¡¨æ€§çš„é¢œè‰²ï¼Œè±¡å¾å‰ç¥¥å–œåº†",
  "short_description_en": "The most representative color in Chinese culture, symbolizing auspiciousness and celebration",
  
  "historical_story_zh": "åœ¨ä¸­å›½å¤ä»£ï¼Œæœ±ç ‚çº¢è¢«ç”¨äºçš‡å®¤å°ç« å’Œå®«å»·è£…é¥°ï¼Œè±¡å¾çš‡æƒå¨ä¸¥ã€‚ç›¸ä¼ æœ±ç ‚å…·æœ‰é©±é‚ªçš„ç¥åŠ›ï¼Œå› æ­¤è¢«å¹¿æ³›åº”ç”¨äºå®—æ•™ä»ªå¼å’Œé‡è¦å…¸ç¤¼ä¸­...",
  
  "historical_story_en": "In ancient China, cinnabar red was used for royal seals and palace decorations, symbolizing imperial authority. Legend has it that cinnabar has the divine power to ward off evil...",
  
  "historical_period": "å¤ä»£",
  "cultural_significance": 0.95,
  
  "traditional_usage": [
    {
      "scene": "wedding",
      "description_zh": "æ–°å¨˜çš„å«è¡£ã€çº¢ç›–å¤´ï¼Œå¯“æ„çº¢çº¢ç«ç«",
      "description_en": "Bride's wedding dress and red veil, symbolizing prosperity"
    },
    {
      "scene": "festival",
      "description_zh": "æ˜¥èŠ‚çº¢ç¯ç¬¼ã€å¯¹è”ï¼Œè¥é€ å–œåº†æ°›å›´", 
      "description_en": "Spring Festival red lanterns and couplets create festive atmosphere"
    }
  ],
  
  "modern_significance_zh": "åœ¨ç°ä»£è®¾è®¡ä¸­ä»£è¡¨åŠ›é‡ã€æ¿€æƒ…å’Œæ´»åŠ›ï¼Œå¸¸ç”¨äºé‡è¦åœºåˆå’Œæ­£å¼æœè£…",
  "modern_significance_en": "Represents strength, passion and vitality in modern design, commonly used in important occasions and formal attire",
  
  "cultural_pairing": [
    {
      "color": "#FFD700",
      "name_zh": "é‡‘é»„",
      "name_en": "Gold",
      "reason_zh": "çº¢é‡‘æ­é…ï¼Œå¯Œè´µå‰ç¥¥",
      "reason_en": "Red and gold pairing symbolizes wealth and fortune"
    }
  ],
  
  "symbolic_meanings": ["prosperity", "protection", "joy", "strength", "celebration"],
  
  "references": [
    "ã€Šä¸­å›½ä¼ ç»Ÿè‰²å½©æ–‡åŒ–ç ”ç©¶ã€‹- ææ˜å",
    "Traditional Chinese Color Culture Research - Li Minghua"
  ],
  
  "image_references": [
    "chinese_red_palace.jpg",
    "traditional_wedding_dress.jpg"
  ],
  
  "created_at": "2025-09-10T00:00:00Z",
  "created_by": "cultural_expert_001",
  "verified_by": "cultural_expert_002",
  "verification_date": "2025-09-10T10:00:00Z",
  "quality_score": 0.98
}
```

### 3. å¤šæ–‡åŒ–é¢œè‰²ç¤ºä¾‹
```json
// ä¸»é¢œè‰²è®°å½•ï¼ˆæ”¯æŒå¤šæ–‡åŒ–ï¼‰
{
  "id": "color_0099",
  "name_zh": "æ·±è“",
  "name_en": "Deep Blue",
  "hex": "#000080",
  "primary_culture": "western",
  "cultural_tags": ["we_cl", "in_hi"],  // è¥¿æ–¹å¤å…¸ + å°åº¦æ•™
  "has_cultural_description": true,
  // ... å…¶ä»–å­—æ®µ
}

// å¯¹åº”çš„ä¸¤æ¡æ–‡åŒ–æè¿°è®°å½•
// è®°å½•1ï¼šè¥¿æ–¹æ–‡åŒ–è§†è§’
{
  "id": "desc_0198",
  "color_id": "color_0099",
  "culture": "western",
  "cultural_tag": "we_cl",
  "priority": 1,  // ä¸»è¦æ–‡åŒ–èƒŒæ™¯
  "description_zh": "åœ¨è¥¿æ–¹æ–‡åŒ–ä¸­ï¼Œæ·±è“ä»£è¡¨æ™ºæ…§ã€æƒå¨å’Œä¿¡ä»»...",
  "description_en": "In Western culture, deep blue represents wisdom, authority and trust..."
  // ... å…¶ä»–å­—æ®µ
}

// è®°å½•2ï¼šå°åº¦æ–‡åŒ–è§†è§’
{
  "id": "desc_0199", 
  "color_id": "color_0099",
  "culture": "indian",
  "cultural_tag": "in_hi",
  "priority": 2,  // æ¬¡è¦æ–‡åŒ–èƒŒæ™¯
  "description_zh": "åœ¨å°åº¦æ•™æ–‡åŒ–ä¸­ï¼Œæ·±è“æ˜¯æ¯—æ¹¿å¥´ç¥çš„é¢œè‰²ï¼Œè±¡å¾ä¿æŠ¤å’Œæ…ˆæ‚²...",
  "description_en": "In Hindu culture, deep blue is the color of Lord Vishnu, symbolizing protection and compassion..."
  // ... å…¶ä»–å­—æ®µ
}
```

## ğŸ”§ ç®€åŒ–çš„APIæ¥å£è®¾è®¡

### 1. é¢œè‰²åˆ—è¡¨APIï¼ˆè½»é‡ç‰ˆï¼‰
```http
GET /api/colors?page=1&limit=50&culture=chinese&season=winter

Response:
{
  "data": [
    {
      "id": "color_0001",
      "hex": "#DC143C",
      "name_zh": "ä¸­å›½çº¢",
      "name_en": "Chinese Red",
      "primary_culture": "chinese",
      "has_cultural_description": true,
      "seasons": ["au", "wi"],
      "scenes": ["ce", "fe"],
      "popularity_score": 0.0
    }
  ],
  "pagination": {
    "current_page": 1,
    "total_pages": 50,
    "total_items": 2500,
    "limit": 50
  }
}
```

### 2. å•ä¸ªé¢œè‰²è¯¦æƒ…API
```http
GET /api/colors/color_0001

Response:
{
  "color": {
    "id": "color_0001",
    "hex": "#DC143C",
    "rgb": {"r": 220, "g": 20, "b": 60},
    "hsl": {"h": 348, "s": 83, "l": 47},
    "name_zh": "ä¸­å›½çº¢",
    "name_en": "Chinese Red",
    "aliases": ["æ·±çº¢", "æœ±çº¢", "çŒ©çº¢"],
    "primary_culture": "chinese",
    "has_cultural_description": true,
    "seasons": ["au", "wi"],
    "scenes": ["ce", "fe", "fo"],
    "moods": ["sa", "wa", "vi"],
    "computed": {
      "brightness": 74,
      "warmth": 85,
      "saturation": 83,
      "contrast_ratio": 0.65
    },
    "stats": {
      "view_count": 0,
      "favorite_count": 0,
      "popularity_score": 0.0
    }
  }
}
```

### 3. ç®€åŒ–çš„æ–‡åŒ–æè¿°APIï¼ˆæŒ‰éœ€åŠ è½½ï¼‰
```http
GET /api/colors/color_0001/cultural-descriptions

Response:
{
  "color_id": "color_0001",
  "descriptions": [
    {
      "id": "desc_0001",
      "culture": "chinese",
      "priority": 1,
      "original_name": "æœ±çº¢",
      "description": "ä¸­å›½çº¢æ˜¯ä¸­åæ–‡åŒ–ä¸­æœ€å…·ä»£è¡¨æ€§çš„é¢œè‰²ï¼Œè±¡å¾ç€å‰ç¥¥ã€å–œåº†ã€å°Šè´µä¸åŠ›é‡...",
      "created_at": "2025-09-10T00:00:00Z"
    }
  ]
}
```_cultural_description": true,
    "seasons": ["au", "wi"],
    "scenes": ["ce", "fe", "fo"],
    "moods": ["sa", "wa", "vi"],
    "computed": {
      "brightness": 74,
      "warmth": 85,
      "saturation": 83,
      "contrast_ratio": 0.65
    },
    "stats": {
      "view_count": 1250,
      "favorite_count": 45,
      "popularity_score": 0.85
    }
  }
}
```

### 3. æ–‡åŒ–æè¿°APIï¼ˆæŒ‰éœ€åŠ è½½ï¼‰
```http
GET /api/colors/color_0001/cultural-descriptions

Response:
{
  "color_id": "color_0001",
  "descriptions": [
    {
      "id": "desc_0001",
      "culture": "chinese",
      "cultural_tag": "ch_tr",
      "priority": 1,
      "description": {
        "zh": "ä¸­å›½çº¢æ˜¯ä¸­åæ–‡åŒ–ä¸­æœ€å…·ä»£è¡¨æ€§çš„é¢œè‰²...",
        "en": "Chinese Red is the most representative color..."
      },
      "short_description": {
        "zh": "ä¸­åæ–‡åŒ–ä¸­æœ€å…·ä»£è¡¨æ€§çš„é¢œè‰²",
        "en": "The most representative color in Chinese culture"
      },
      "historical_story": {
        "zh": "åœ¨ä¸­å›½å¤ä»£ï¼Œæœ±ç ‚çº¢è¢«ç”¨äºçš‡å®¤å°ç« ...",
        "en": "In ancient China, cinnabar red was used for royal seals..."
      },
      "traditional_usage": [...],
      "cultural_pairing": [...],
      "symbolic_meanings": [...],
      "cultural_significance": 0.95
    }
  ]
}
```

### 4. æ‰¹é‡é¢œè‰²API
```http
POST /api/colors/batch
Content-Type: application/json

{
  "color_ids": ["color_0001", "color_0002", "color_0003"],
  "include_cultural": false
}

Response:
{
  "colors": [
    {
      "id": "color_0001",
      "hex": "#DC143C",
      "name_zh": "ä¸­å›½çº¢",
      // ... åŸºç¡€å­—æ®µ
    }
  ]
}
```

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 1. æ•°æ®åº“ç´¢å¼•
```sql
-- ä¸»é¢œè‰²è¡¨æ ¸å¿ƒç´¢å¼•
CREATE INDEX idx_colors_hex ON colors(hex);
CREATE INDEX idx_colors_culture ON colors(primary_culture, status);
CREATE INDEX idx_colors_popularity ON colors(popularity_score DESC, view_count DESC);
CREATE INDEX idx_colors_search ON colors(search_boost DESC, popularity_score DESC);
CREATE INDEX idx_colors_cultural_flag ON colors(has_cultural_description, primary_culture);

-- æ–‡åŒ–æè¿°è¡¨ç´¢å¼•
CREATE INDEX idx_cultural_desc_color ON color_cultural_descriptions(color_id, priority);
CREATE INDEX idx_cultural_desc_culture ON color_cultural_descriptions(culture, cultural_tag);

-- å¤åˆç´¢å¼•ä¼˜åŒ–
CREATE INDEX idx_colors_filter ON colors(status, primary_culture, popularity_score DESC);
```

### 2. ç¼“å­˜ç­–ç•¥
```javascript
// Redisç¼“å­˜é”®å‘½åè§„èŒƒ
const CACHE_KEYS = {
  COLOR_LIST: 'colors:list:{page}:{filters_hash}',           // é¢œè‰²åˆ—è¡¨
  COLOR_DETAIL: 'colors:detail:{color_id}',                 // é¢œè‰²è¯¦æƒ…
  CULTURAL_DESC: 'colors:cultural:{color_id}',              // æ–‡åŒ–æè¿°
  POPULAR_COLORS: 'colors:popular:{limit}',                 // çƒ­é—¨é¢œè‰²
  SEARCH_RESULTS: 'colors:search:{query_hash}:{page}',         // æœç´¢ç»“æœ
  CLASSIFICATION_DICT: 'colors:dict:{category}',            // åˆ†ç±»å­—å…¸
  COLOR_STATS: 'colors:stats:{color_id}',                   // é¢œè‰²ç»Ÿè®¡
  USER_FAVORITES: 'user:favorites:{user_id}',               // ç”¨æˆ·æ”¶è—
}

// ç¼“å­˜è¿‡æœŸæ—¶é—´è®¾ç½®
const CACHE_TTL = {
  COLOR_LIST: 3600,        // 1å°æ—¶
  COLOR_DETAIL: 7200,      // 2å°æ—¶
  CULTURAL_DESC: 86400,    // 24å°æ—¶ï¼ˆæ–‡åŒ–æè¿°æ›´æ–°é¢‘ç‡ä½ï¼‰
  POPULAR_COLORS: 1800,    // 30åˆ†é’Ÿ
  SEARCH_RESULTS: 900,     // 15åˆ†é’Ÿ
  CLASSIFICATION_DICT: 86400 * 7,  // 7å¤©ï¼ˆå­—å…¸æ•°æ®å˜åŒ–å°‘ï¼‰
  COLOR_STATS: 300,        // 5åˆ†é’Ÿï¼ˆç»Ÿè®¡æ•°æ®æ›´æ–°é¢‘ç¹ï¼‰
}
```

### 3. åˆ†é¡µä¼˜åŒ–
```javascript
// åŸºäºæ¸¸æ ‡çš„åˆ†é¡µï¼ˆæ€§èƒ½æ›´å¥½ï¼‰
class ColorPagination {
  async getColorsByCursor(cursor = null, limit = 50, filters = {}) {
    let query = `
      SELECT id, hex, name_zh, name_en, primary_culture, 
             cultural_tags, has_cultural_description, 
             popularity_score, created_at
      FROM colors 
      WHERE status = 'active'
    `
    
    const params = []
    
    // æ·»åŠ ç­›é€‰æ¡ä»¶
    if (filters.culture) {
      query += ` AND primary_culture = ?`
      params.push(filters.culture)
    }
    
    if (filters.has_cultural) {
      query += ` AND has_cultural_description = ?`
      params.push(filters.has_cultural)
    }
    
    // æ¸¸æ ‡åˆ†é¡µ
    if (cursor) {
      query += ` AND (popularity_score, id) < (?, ?)`
      params.push(cursor.popularity_score, cursor.id)
    }
    
    query += ` ORDER BY popularity_score DESC, id DESC LIMIT ?`
    params.push(limit + 1)  // å¤šæŸ¥ä¸€æ¡ç”¨äºåˆ¤æ–­æ˜¯å¦æœ‰ä¸‹é¡µ
    
    const results = await db.query(query, params)
    const hasNext = results.length > limit
    
    if (hasNext) {
      results.pop()  // ç§»é™¤å¤šæŸ¥çš„é‚£æ¡
    }
    
    const nextCursor = hasNext ? {
      popularity_score: results[results.length - 1].popularity_score,
      id: results[results.length - 1].id
    } : null
    
    return {
      data: results,
      next_cursor: nextCursor,
      has_next: hasNext
    }
  }
}
```

### 4. æ•°æ®é¢„åŠ è½½
```javascript
// çƒ­é—¨æ•°æ®é¢„åŠ è½½
class ColorDataPreloader {
  async preloadHotData() {
    try {
      // é¢„åŠ è½½çƒ­é—¨é¢œè‰²
      await this.preloadPopularColors()
      
      // é¢„åŠ è½½åˆ†ç±»å­—å…¸
      await this.preloadClassificationDicts()
      
      // é¢„åŠ è½½çƒ­é—¨æ–‡åŒ–æè¿°
      await this.preloadPopularCulturalDescriptions()
      
      console.log('çƒ­é—¨æ•°æ®é¢„åŠ è½½å®Œæˆ')
    } catch (error) {
      console.error('æ•°æ®é¢„åŠ è½½å¤±è´¥:', error)
    }
  }
  
  async preloadPopularColors() {
    const popularColors = await db.query(`
      SELECT * FROM colors 
      WHERE status = 'active' 
      ORDER BY popularity_score DESC 
      LIMIT 100
    `)
    
    // æ‰¹é‡å†™å…¥ç¼“å­˜
    const pipeline = redis.pipeline()
    popularColors.forEach(color => {
      const cacheKey = `colors:detail:${color.id}`
      pipeline.setex(cacheKey, 7200, JSON.stringify(color))
    })
    await pipeline.exec()
  }
  
  async preloadClassificationDicts() {
    const categories = ['seasons', 'scenes', 'moods', 'styles', 'cultural_tags']
    
    for (const category of categories) {
      const items = await db.query(`
        SELECT code, name_zh, name_en, description_zh, description_en
        FROM classification_dictionaries 
        WHERE category = ? AND is_active = 1
        ORDER BY sort_order
      `, [category])
      
      const cacheKey = `colors:dict:${category}`
      await redis.setex(cacheKey, 86400 * 7, JSON.stringify(items))
    }
  }
}
```

## ğŸ¨ å‰ç«¯æ•°æ®ç»“æ„

### 1. Vue Storeç»“æ„
```javascript
// stores/colorStore.js
import { defineStore } from 'pinia'

export const useColorStore = defineStore('colors', {
  state: () => ({
    // é¢œè‰²åˆ—è¡¨æ•°æ®
    colors: [],
    totalColors: 0,
    currentPage: 1,
    pageSize: 50,
    loading: false,
    
    // ç­›é€‰æ¡ä»¶
    filters: {
      culture: null,
      seasons: [],
      scenes: [],
      moods: [],
      styles: [],
      has_cultural: null,
      search_query: ''
    },
    
    // æ’åºæ¡ä»¶
    sort: {
      field: 'popularity_score',
      order: 'desc'
    },
    
    // é€‰ä¸­çš„é¢œè‰²
    selectedColor: null,
    
    // åˆ†ç±»å­—å…¸ï¼ˆç¼“å­˜ï¼‰
    dictionaries: {
      cultures: {},
      seasons: {},
      scenes: {},
      moods: {},
      styles: {},
      cultural_tags: {},
      religious_contexts: {},
      symbolic_categories: {}
    },
    
    // ç”¨æˆ·æ”¶è—
    favorites: new Set(),
    
    // æœç´¢å†å²
    searchHistory: []
  }),
  
  getters: {
    // ç­›é€‰åçš„é¢œè‰²åˆ—è¡¨
    filteredColors() {
      return this.colors.filter(color => {
        // æ–‡åŒ–ç­›é€‰
        if (this.filters.culture && color.primary_culture !== this.filters.culture) {
          return false
        }
        
        // å­£èŠ‚ç­›é€‰
        if (this.filters.seasons.length > 0) {
          const hasMatchingSeason = this.filters.seasons.some(season => 
            color.seasons?.includes(season)
          )
          if (!hasMatchingSeason) return false
        }
        
        // åœºæ™¯ç­›é€‰
        if (this.filters.scenes.length > 0) {
          const hasMatchingScene = this.filters.scenes.some(scene => 
            color.scenes?.includes(scene)
          )
          if (!hasMatchingScene) return false
        }
        
        // æ–‡åŒ–æè¿°ç­›é€‰
        if (this.filters.has_cultural !== null) {
          if (color.has_cultural_description !== this.filters.has_cultural) {
            return false
          }
        }
        
        // æœç´¢æŸ¥è¯¢ç­›é€‰
        if (this.filters.search_query) {
          const query = this.filters.search_query.toLowerCase()
          const searchText = `${color.name_zh} ${color.name_en} ${color.hex} ${color.aliases?.join(' ') || ''}`.toLowerCase()
          if (!searchText.includes(query)) return false
        }
        
        return true
      })
    },
    
    // æ”¶è—çš„é¢œè‰²
    favoriteColors() {
      return this.colors.filter(color => this.favorites.has(color.id))
    },
    
    // æŒ‰æ–‡åŒ–åˆ†ç»„çš„é¢œè‰²
    colorsByCulture() {
      const grouped = {}
      this.filteredColors.forEach(color => {
        const culture = color.primary_culture
        if (!grouped[culture]) {
          grouped[culture] = []
        }
        grouped[culture].push(color)
      })
      return grouped
    },
    
    // çƒ­é—¨é¢œè‰²ï¼ˆå‰20ï¼‰
    popularColors() {
      return this.colors
        .sort((a, b) => b.popularity_score - a.popularity_score)
        .slice(0, 20)
    }
  },
  
  actions: {
    // åŠ è½½é¢œè‰²åˆ—è¡¨
    async loadColors(page = 1, resetList = false) {
      this.loading = true
      
      try {
        const params = {
          page,
          limit: this.pageSize,
          ...this.filters,
          sort_field: this.sort.field,
          sort_order: this.sort.order
        }
        
        const response = await colorApi.getColors(params)
        
        if (resetList || page === 1) {
          this.colors = response.data
        } else {
          this.colors.push(...response.data)
        }
        
        this.totalColors = response.pagination.total_items
        this.currentPage = page
        
      } catch (error) {
        console.error('åŠ è½½é¢œè‰²åˆ—è¡¨å¤±è´¥:', error)
        throw error
      } finally {
        this.loading = false
      }
    },
    
    // åŠ è½½å•ä¸ªé¢œè‰²è¯¦æƒ…
    async loadColorDetail(colorId) {
      try {
        const response = await colorApi.getColorDetail(colorId)
        this.selectedColor = response.color
        return response.color
      } catch (error) {
        console.error('åŠ è½½é¢œè‰²è¯¦æƒ…å¤±è´¥:', error)
        throw error
      }
    },
    
    // åŠ è½½åˆ†ç±»å­—å…¸
    async loadDictionaries() {
      try {
        const categories = ['cultures', 'seasons', 'scenes', 'moods', 'styles', 'cultural_tags']
        
        for (const category of categories) {
          const response = await colorApi.getDictionary(category)
          this.dictionaries[category] = response.data.reduce((acc, item) => {
            acc[item.code] = item
            return acc
          }, {})
        }
      } catch (error) {
        console.error('åŠ è½½åˆ†ç±»å­—å…¸å¤±è´¥:', error)
      }
    },
    
    // æ›´æ–°ç­›é€‰æ¡ä»¶
    updateFilters(newFilters) {
      this.filters = { ...this.filters, ...newFilters }
      this.loadColors(1, true)  // é‡æ–°åŠ è½½ç¬¬ä¸€é¡µ
    },
    
    // æ›´æ–°æ’åºæ¡ä»¶
    updateSort(field, order = 'desc') {
      this.sort = { field, order }
      this.loadColors(1, true)  // é‡æ–°åŠ è½½ç¬¬ä¸€é¡µ
    },
    
    // åˆ‡æ¢æ”¶è—çŠ¶æ€
    toggleFavorite(colorId) {
      if (this.favorites.has(colorId)) {
        this.favorites.delete(colorId)
      } else {
        this.favorites.add(colorId)
      }
      
      // åŒæ­¥åˆ°åç«¯ï¼ˆå¯é€‰ï¼‰
      this.syncFavoritesToServer()
    },
    
    // åŒæ­¥æ”¶è—åˆ°æœåŠ¡å™¨
    async syncFavoritesToServer() {
      try {
        await userApi.updateFavorites(Array.from(this.favorites))
      } catch (error) {
        console.error('åŒæ­¥æ”¶è—å¤±è´¥:', error)
      }
    },
    
    // æ·»åŠ æœç´¢å†å²
    addSearchHistory(query) {
      if (query && !this.searchHistory.includes(query)) {
        this.searchHistory.unshift(query)
        if (this.searchHistory.length > 10) {
          this.searchHistory = this.searchHistory.slice(0, 10)
        }
        
        // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
        localStorage.setItem('color_search_history', JSON.stringify(this.searchHistory))
      }
    },
    
    // åŠ è½½æœç´¢å†å²
    loadSearchHistory() {
      const saved = localStorage.getItem('color_search_history')
      if (saved) {
        this.searchHistory = JSON.parse(saved)
      }
    },
    
    // æ¸…é™¤æ‰€æœ‰ç­›é€‰
    clearFilters() {
      this.filters = {
        culture: null,
        seasons: [],
        scenes: [],
        moods: [],
        styles: [],
        has_cultural: null,
        search_query: ''
      }
      this.loadColors(1, true)
    }
  }
})
```

### 2. æ–‡åŒ–æè¿°Store
```javascript
// stores/culturalStore.js
import { defineStore } from 'pinia'

export const useCulturalStore = defineStore('cultural', {
  state: () => ({
    // æ–‡åŒ–æè¿°ç¼“å­˜
    descriptions: new Map(),  // colorId -> descriptions[]
    
    // åŠ è½½çŠ¶æ€
    loadingStates: new Set(), // æ­£åœ¨åŠ è½½çš„colorIdé›†åˆ
    
    // é”™è¯¯çŠ¶æ€
    errors: new Map()         // colorId -> error
  }),
  
  getters: {
    // è·å–æŒ‡å®šé¢œè‰²çš„æ–‡åŒ–æè¿°
    getDescriptions: (state) => (colorId) => {
      return state.descriptions.get(colorId) || []
    },
    
    // æ£€æŸ¥æ˜¯å¦æ­£åœ¨åŠ è½½
    isLoading: (state) => (colorId) => {
      return state.loadingStates.has(colorId)
    },
    
    // è·å–ä¸»è¦æ–‡åŒ–æè¿°ï¼ˆpriorityæœ€å°çš„ï¼‰
    getPrimaryDescription: (state) => (colorId) => {
      const descriptions = state.descriptions.get(colorId) || []
      return descriptions.find(desc => desc.priority === 1) || descriptions[0]
    }
  },
  
  actions: {
    // åŠ è½½æ–‡åŒ–æè¿°
    async loadCulturalDescriptions(colorId) {
      // æ£€æŸ¥ç¼“å­˜
      if (this.descriptions.has(colorId)) {
        return this.descriptions.get(colorId)
      }
      
      // æ£€æŸ¥æ˜¯å¦æ­£åœ¨åŠ è½½
      if (this.loadingStates.has(colorId)) {
        // ç­‰å¾…åŠ è½½å®Œæˆ
        return new Promise((resolve) => {
          const checkCache = () => {
            if (this.descriptions.has(colorId)) {
              resolve(this.descriptions.get(colorId))
            } else if (!this.loadingStates.has(colorId)) {
              resolve([])  // åŠ è½½å¤±è´¥
            } else {
              setTimeout(checkCache, 100)
            }
          }
          checkCache()
        })
      }
      
      // å¼€å§‹åŠ è½½
      this.loadingStates.add(colorId)
      this.errors.delete(colorId)
      
      try {
        const response = await colorApi.getCulturalDescriptions(colorId)
        const descriptions = response.descriptions || []
        
        // æŒ‰priorityæ’åº
        descriptions.sort((a, b) => a.priority - b.priority)
        
        // ç¼“å­˜ç»“æœ
        this.descriptions.set(colorId, descriptions)
        
        return descriptions
      } catch (error) {
        console.error(`åŠ è½½é¢œè‰²${colorId}çš„æ–‡åŒ–æè¿°å¤±è´¥:`, error)
        this.errors.set(colorId, error)
        return []
      } finally {
        this.loadingStates.delete(colorId)
      }
    },
    
    // é¢„åŠ è½½çƒ­é—¨é¢œè‰²çš„æ–‡åŒ–æè¿°
    async preloadPopularDescriptions(colorIds) {
      const concurrencyLimit = 3
      const chunks = this.chunkArray(colorIds, concurrencyLimit)
      
      for (const chunk of chunks) {
        await Promise.all(
          chunk.map(colorId => 
            this.loadCulturalDescriptions(colorId).catch(console.error)
          )
        )
      }
    },
    
    // æ¸…é™¤ç¼“å­˜
    clearCache() {
      this.descriptions.clear()
      this.errors.clear()
    },
    
    // å·¥å…·æ–¹æ³•ï¼šæ•°ç»„åˆ†å—
    chunkArray(array, size) {
      const chunks = []
      for (let i = 0; i < array.length; i += size) {
        chunks.push(array.slice(i, i + size))
      }
      return chunks
    }
  }
})
```

## ğŸ”§ æ•°æ®è¿ç§»è„šæœ¬

### 1. æ—§æ•°æ®ç»“æ„è¿ç§»
```sql
-- æ•°æ®è¿ç§»è„šæœ¬ï¼šä»æ—§çš„å¤æ‚åˆ†ç±»åˆ°æ–°çš„ç®€åŒ–åˆ†ç±»

-- 1. åˆ›å»ºæ˜ å°„ä¸´æ—¶è¡¨
CREATE TEMPORARY TABLE tag_migration_mapping (
  old_category VARCHAR(50),
  old_tag VARCHAR(50),
  new_category VARCHAR(50),
  new_tag VARCHAR(10),
  PRIMARY KEY (old_category, old_tag)
);

-- 2. æ’å…¥æ˜ å°„è§„åˆ™
INSERT INTO tag_migration_mapping VALUES
-- æ–‡åŒ–é£æ ¼åˆå¹¶
('aesthetic_tags', 'indian_traditional', 'cultural_tags', 'in_tr'),
('cultural_themes', 'hindu_traditional', 'cultural_tags', 'in_tr'),
('regional_styles', 'pan_indian', 'cultural_tags', 'in_tr'),
('cultural_periods', 'ancient_india', 'cultural_tags', 'in_tr'),

('aesthetic_tags', 'chinese_traditional', 'cultural_tags', 'ch_tr'),
('cultural_periods', 'tang_china', 'cultural_tags', 'ch_tr'),
('cultural_periods', 'ming_china', 'cultural_tags', 'ch_tr'),

('aesthetic_tags', 'japanese_zen', 'cultural_tags', 'jp_ze'),
('cultural_themes', 'zen_aesthetics', 'cultural_tags', 'jp_ze'),

-- è±¡å¾æ„ä¹‰å‡çº§
('symbolic_meanings', 'purity', 'symbolic_categories', 'sp'),
('symbolic_meanings', 'blessing', 'symbolic_categories', 'sp'),
('symbolic_meanings', 'prosperity', 'symbolic_categories', 'ab'),
('symbolic_meanings', 'wealth', 'symbolic_categories', 'ab'),
('symbolic_meanings', 'protection', 'symbolic_categories', 'pr'),
('symbolic_meanings', 'healing', 'symbolic_categories', 'he');

-- 3. è¿ç§»æ•°æ®ï¼ˆå‡è®¾æ—§è¡¨åä¸ºold_colorsï¼‰
UPDATE colors c
SET cultural_tags = (
  SELECT JSON_ARRAYAGG(DISTINCT tm.new_tag)
  FROM old_color_tags oct
  JOIN tag_migration_mapping tm ON (
    oct.tag_category = tm.old_category AND 
    oct.tag_value = tm.old_tag
  )
  WHERE oct.color_id = c.id AND tm.new_category = 'cultural_tags'
)
WHERE EXISTS (
  SELECT 1 FROM old_color_tags oct2 
  WHERE oct2.color_id = c.id
);

-- 4. æ›´æ–°has_cultural_descriptionæ ‡è¯†
UPDATE colors 
SET has_cultural_description = TRUE
WHERE cultural_tags IS NOT NULL 
  AND JSON_LENGTH(cultural_tags) > 0;
```

### 2. æ•°æ®éªŒè¯è„šæœ¬
```sql
-- æ•°æ®å®Œæ•´æ€§éªŒè¯

-- 1. æ£€æŸ¥å¿…å¡«å­—æ®µ
SELECT 'Missing required fields' as issue, COUNT(*) as count
FROM colors 
WHERE hex IS NULL OR name_zh IS NULL OR primary_culture IS NULL;

-- 2. æ£€æŸ¥é¢œè‰²å€¼æ ¼å¼
SELECT 'Invalid hex format' as issue, COUNT(*) as count
FROM colors 
WHERE hex NOT REGEXP '^#[0-9A-Fa-f]{6};

-- 3. æ£€æŸ¥RGBå€¼èŒƒå›´
SELECT 'Invalid RGB values' as issue, COUNT(*) as count
FROM colors 
WHERE rgb_r > 255 OR rgb_g > 255 OR rgb_b > 255 
   OR rgb_r < 0 OR rgb_g < 0 OR rgb_b < 0;

-- 4. æ£€æŸ¥æ–‡åŒ–æè¿°å…³è”å®Œæ•´æ€§
SELECT 'Orphaned cultural descriptions' as issue, COUNT(*) as count
FROM color_cultural_descriptions ccd
LEFT JOIN colors c ON ccd.color_id = c.id
WHERE c.id IS NULL;

-- 5. æ£€æŸ¥has_cultural_descriptionæ ‡è¯†å‡†ç¡®æ€§
SELECT 'Incorrect cultural description flag' as issue, COUNT(*) as count
FROM colors c
LEFT JOIN color_cultural_descriptions ccd ON c.id = ccd.color_id
WHERE (c.has_cultural_description = TRUE AND ccd.color_id IS NULL)
   OR (c.has_cultural_description = FALSE AND ccd.color_id IS NOT NULL);

-- 6. æ£€æŸ¥JSONå­—æ®µæ ¼å¼
SELECT 'Invalid JSON in cultural_tags' as issue, COUNT(*) as count
FROM colors 
WHERE cultural_tags IS NOT NULL AND NOT JSON_VALID(cultural_tags);
```

## ğŸ“± ç§»åŠ¨ç«¯ä¼˜åŒ–

### 1. å“åº”å¼å­—æ®µé€‰æ‹©
```javascript
// ç§»åŠ¨ç«¯APIï¼šè¿”å›ç²¾ç®€å­—æ®µ
const mobileColorFields = [
  'id', 'hex', 'name_zh', 'primary_culture', 
  'has_cultural_description', 'popularity_score'
]

// æ¡Œé¢ç«¯APIï¼šè¿”å›å®Œæ•´å­—æ®µ
const desktopColorFields = [
  'id', 'hex', 'rgb_r', 'rgb_g', 'rgb_b', 'hsl_h', 'hsl_s', 'hsl_l',
  'name_zh', 'name_en', 'aliases', 'primary_culture', 'cultural_tags',
  'has_cultural_description', 'seasons', 'scenes', 'moods', 'styles',
  'brightness', 'warmth', 'saturation', 'popularity_score'
]

class ColorAPIService {
  async getColors(params = {}) {
    const isMobile = this.detectMobile()
    const fields = isMobile ? mobileColorFields : desktopColorFields
    
    return await fetch('/api/colors', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ ...params, fields })
    })
  }
  
  detectMobile() {
    return window.innerWidth < 768 || /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
  }
}
```

### 2. å›¾ç‰‡æ‡’åŠ è½½
```vue
<!-- é¢œè‰²å¡ç‰‡ç»„ä»¶ï¼šç§»åŠ¨ç«¯ä¼˜åŒ– -->
<template>
  <div class="color-card" :class="{ 'mobile': isMobile }">
    <!-- é¢œè‰²é¢„è§ˆåŒºåŸŸ -->
    <div 
      class="color-preview"
      :style="{ backgroundColor: color.hex }"
      @click="handleColorClick"
    >
      <!-- æ‡’åŠ è½½çš„èƒŒæ™¯å›¾æ¡ˆï¼ˆä»…æ¡Œé¢ç«¯ï¼‰ -->
      <div 
        v-if="!isMobile && color.has_cultural_description"
        class="cultural-pattern"
        v-lazy-background="culturalPatternUrl"
      ></div>
    </div>
    
    <!-- åŸºç¡€ä¿¡æ¯ -->
    <div class="color-info">
      <h3 class="color-name">{{ color.name_zh }}</h3>
      <p class="color-hex">{{ color.hex }}</p>
      
      <!-- æ–‡åŒ–æ ‡è¯†ï¼ˆç²¾ç®€æ˜¾ç¤ºï¼‰ -->
      <div 
        v-if="color.has_cultural_description" 
        class="cultural-badge"
      >
        <icon name="culture" size="small" />
      </div>
    </div>
    
    <!-- è¯¦æƒ…åŒºåŸŸï¼ˆæŒ‰éœ€å±•å¼€ï¼‰ -->
    <transition name="expand">
      <div v-if="expanded" class="color-details">
        <cultural-description 
          :color-id="color.id"
          :compact="isMobile"
        />
      </div>
    </transition>
  </div>
</template>

<script setup>
import { ref, computed } from 'vue'
import { useDeviceDetection } from '@/composables/deviceDetection'

const props = defineProps(['color'])
const expanded = ref(false)
const { isMobile } = useDeviceDetection()

const culturalPatternUrl = computed(() => {
  if (!props.color.cultural_tags?.length) return null
  const tag = props.color.cultural_tags[0]
  return `/images/patterns/${tag}.svg`
})

const handleColorClick = () => {
  if (isMobile.value) {
    // ç§»åŠ¨ç«¯ï¼šç›´æ¥è·³è½¬åˆ°è¯¦æƒ…é¡µ
    router.push(`/colors/${props.color.id}`)
  } else {
    // æ¡Œé¢ç«¯ï¼šå±•å¼€è¯¦æƒ…
    expanded.value = !expanded.value
  }
}
</script>
```

## ğŸ” æœç´¢ä¼˜åŒ–

### 1. å…¨æ–‡æœç´¢é…ç½®
```sql
-- åˆ›å»ºå…¨æ–‡æœç´¢ç´¢å¼•
ALTER TABLE colors ADD FULLTEXT(search_keywords);

-- æœç´¢æŸ¥è¯¢ä¼˜åŒ–
SELECT 
  c.*,
  MATCH(c.search_keywords) AGAINST (? IN NATURAL LANGUAGE MODE) as relevance_score
FROM colors c
WHERE 
  c.status = 'active' AND
  (
    MATCH(c.search_keywords) AGAINST (? IN NATURAL LANGUAGE MODE) OR
    c.name_zh LIKE CONCAT('%', ?, '%') OR
    c.name_en LIKE CONCAT('%', ?, '%') OR
    c.hex = ?
  )
ORDER BY 
  CASE 
    WHEN c.hex = ? THEN 100
    WHEN c.name_zh = ? THEN 90
    WHEN c.name_en = ? THEN 85
    ELSE relevance_score * c.search_boost
  END DESC,
  c.popularity_score DESC
LIMIT 50;
```

### 2. æœç´¢å»ºè®®
```javascript
// æœç´¢å»ºè®®æœåŠ¡
class SearchSuggestionService {
  async getSuggestions(query, limit = 10) {
    if (query.length < 2) return []
    
    try {
      // å¹¶è¡ŒæŸ¥è¯¢å¤šä¸ªæ•°æ®æº
      const [colorSuggestions, culturalSuggestions, categorySuggestions] = await Promise.all([
        this.getColorNameSuggestions(query, limit),
        this.getCulturalTagSuggestions(query, limit),
        this.getCategorySuggestions(query, limit)
      ])
      
      // åˆå¹¶å’Œå»é‡
      const allSuggestions = [
        ...colorSuggestions.map(item => ({ ...item, type: 'color' })),
        ...culturalSuggestions.map(item => ({ ...item, type: 'cultural' })),
        ...categorySuggestions.map(item => ({ ...item, type: 'category' }))
      ]
      
      // æŒ‰ç›¸å…³æ€§æ’åº
      return allSuggestions
        .sort((a, b) => b.relevance - a.relevance)
        .slice(0, limit)
        
    } catch (error) {
      console.error('è·å–æœç´¢å»ºè®®å¤±è´¥:', error)
      return []
    }
  }
  
  async getColorNameSuggestions(query, limit) {
    const response = await fetch(`/api/search/colors/suggest`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ query, limit })
    })
    return response.json()
  }
  
  async getCulturalTagSuggestions(query, limit) {
    const response = await fetch(`/api/search/cultural/suggest`, {
      method: 'POST', 
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ query, limit })
    })
    return response.json()
  }
}
```

## ğŸ“ˆ ç›‘æ§å’Œåˆ†æ

### 1. æ€§èƒ½ç›‘æ§
```javascript
// æ€§èƒ½ç›‘æ§æœåŠ¡
class ColorSystemMonitor {
  constructor() {
    this.metrics = {
      api_response_times: {},
      cache_hit_rates: {},
      user_interactions: {},
      error_rates: {}
    }
  }
  
  // è®°å½•APIå“åº”æ—¶é—´
  recordAPITiming(endpoint, duration) {
    if (!this.metrics.api_response_times[endpoint]) {
      this.metrics.api_response_times[endpoint] = []
    }
    
    this.metrics.api_response_times[endpoint].push({
      duration,
      timestamp: Date.now()
    })
    
    // åªä¿ç•™æœ€è¿‘1000æ¡è®°å½•
    if (this.metrics.api_response_times[endpoint].length > 1000) {
      this.metrics.api_response_times[endpoint] = 
        this.metrics.api_response_times[endpoint].slice(-1000)
    }
  }
  
  // è®°å½•ç¼“å­˜å‘½ä¸­ç‡
  recordCacheHit(cacheType, hit) {
    if (!this.metrics.cache_hit_rates[cacheType]) {
      this.metrics.cache_hit_rates[cacheType] = { hits: 0, total: 0 }
    }
    
    this.metrics.cache_hit_rates[cacheType].total++
    if (hit) {
      this.metrics.cache_hit_rates[cacheType].hits++
    }
  }
  
  // ç”Ÿæˆæ€§èƒ½æŠ¥å‘Š
  generatePerformanceReport() {
    const report = {
      timestamp: new Date().toISOString(),
      api_performance: {},
      cache_performance: {},
      summary: {}
    }
    
    // APIæ€§èƒ½ç»Ÿè®¡
    Object.entries(this.metrics.api_response_times).forEach(([endpoint, timings]) => {
      const recent = timings.filter(t => Date.now() - t.timestamp < 3600000) // æœ€è¿‘1å°æ—¶
      if (recent.length > 0) {
        const durations = recent.map(t => t.duration)
        report.api_performance[endpoint] = {
          avg: durations.reduce((a, b) => a + b) / durations.length,
          p95: this.percentile(durations, 95),
          p99: this.percentile(durations, 99),
          count: recent.length
        }
      }
    })
    
    // ç¼“å­˜æ€§èƒ½ç»Ÿè®¡
    Object.entries(this.metrics.cache_hit_rates).forEach(([cacheType, stats]) => {
      report.cache_performance[cacheType] = {
        hit_rate: stats.total > 0 ? (stats.hits / stats.total * 100).toFixed(2) : 0,
        total_requests: stats.total
      }
    })
    
    return report
  }
  
  percentile(arr, p) {
    const sorted = arr.sort((a, b) => a - b)
    const index = Math.ceil(sorted.length * p / 100) - 1
    return sorted[index]
  }
}
```

### 2. ç”¨æˆ·è¡Œä¸ºåˆ†æ
```javascript
// ç”¨æˆ·è¡Œä¸ºåˆ†ææœåŠ¡
class UserBehaviorAnalytics {
  constructor() {
    this.events = []
    this.sessionData = {
      session_id: this.generateSessionId(),
      start_time: Date.now(),
      user_agent: navigator.userAgent,
      screen_resolution: `${screen.width}x${screen.height}`,
      device_type: this.detectDeviceType()
    }
  }
  
  // è®°å½•é¢œè‰²æŸ¥çœ‹äº‹ä»¶
  trackColorView(colorId, colorHex, source = 'list') {
    this.recordEvent('color_view', {
      color_id: colorId,
      color_hex: colorHex,
      source, // 'list', 'search', 'recommendation', 'detail'
      timestamp: Date.now()
    })
    
    // åŒæ­¥åˆ°åç«¯
    this.syncViewEvent(colorId)
  }
  
  // è®°å½•é¢œè‰²æ”¶è—äº‹ä»¶
  trackColorFavorite(colorId, action) {
    this.recordEvent('color_favorite', {
      color_id: colorId,
      action, // 'add' or 'remove'
      timestamp: Date.now()
    })
  }
  
  // è®°å½•ç­›é€‰å™¨ä½¿ç”¨
  trackFilterUsage(filterType, filterValue, resultCount) {
    this.recordEvent('filter_usage', {
      filter_type: filterType, // 'culture', 'season', 'scene', etc.
      filter_value: filterValue,
      result_count: resultCount,
      timestamp: Date.now()
    })
  }
  
  // è®°å½•æœç´¢è¡Œä¸º
  trackSearch(query, resultCount, selectedResult = null) {
    this.recordEvent('search', {
      query,
      result_count: resultCount,
      selected_result: selectedResult,
      timestamp: Date.now()
    })
  }
  
  // è®°å½•æ–‡åŒ–æè¿°æŸ¥çœ‹
  trackCulturalDescriptionView(colorId, culture) {
    this.recordEvent('cultural_description_view', {
      color_id: colorId,
      culture,
      timestamp: Date.now()
    })
  }
  
  // è®°å½•é¡µé¢åœç•™æ—¶é—´
  trackPageDwell(pageType, dwellTime) {
    this.recordEvent('page_dwell', {
      page_type: pageType, // 'color_list', 'color_detail', 'search_results'
      dwell_time: dwellTime, // æ¯«ç§’
      timestamp: Date.now()
    })
  }
  
  // é€šç”¨äº‹ä»¶è®°å½•
  recordEvent(eventType, data) {
    const event = {
      session_id: this.sessionData.session_id,
      event_type: eventType,
      data,
      url: window.location.href,
      timestamp: Date.now()
    }
    
    this.events.push(event)
    
    // æ‰¹é‡å‘é€äº‹ä»¶ï¼ˆæ¯50ä¸ªäº‹ä»¶æˆ–æ¯5åˆ†é’Ÿï¼‰
    if (this.events.length >= 50 || this.shouldSendBatch()) {
      this.sendEventBatch()
    }
  }
  
  // å‘é€äº‹ä»¶æ‰¹æ¬¡åˆ°åç«¯
  async sendEventBatch() {
    if (this.events.length === 0) return
    
    try {
      await fetch('/api/analytics/events', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          session: this.sessionData,
          events: this.events
        })
      })
      
      // æ¸…ç©ºå·²å‘é€çš„äº‹ä»¶
      this.events = []
      
    } catch (error) {
      console.error('å‘é€åˆ†æäº‹ä»¶å¤±è´¥:', error)
      // ä¿ç•™äº‹ä»¶ï¼Œä¸‹æ¬¡å†è¯•
    }
  }
  
  // åŒæ­¥é¢œè‰²æŸ¥çœ‹æ•°åˆ°åç«¯
  async syncViewEvent(colorId) {
    try {
      await fetch(`/api/colors/${colorId}/view`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' }
      })
    } catch (error) {
      // å¿½ç•¥åŒæ­¥å¤±è´¥ï¼Œä¸å½±å“ç”¨æˆ·ä½“éªŒ
      console.warn('åŒæ­¥æŸ¥çœ‹æ•°æ®å¤±è´¥:', error)
    }
  }
  
  // ç”Ÿæˆä¼šè¯ID
  generateSessionId() {
    return `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  }
  
  // æ£€æµ‹è®¾å¤‡ç±»å‹
  detectDeviceType() {
    const ua = navigator.userAgent
    if (/tablet|ipad|playbook|silk/i.test(ua)) return 'tablet'
    if (/mobile|iphone|ipod|android|blackberry|opera|mini|windows\sce|palm|smartphone|iemobile/i.test(ua)) return 'mobile'
    return 'desktop'
  }
  
  // é¡µé¢å¸è½½æ—¶å‘é€å‰©ä½™äº‹ä»¶
  onPageUnload() {
    if (this.events.length > 0) {
      // ä½¿ç”¨sendBeaconç¡®ä¿æ•°æ®å‘é€
      navigator.sendBeacon('/api/analytics/events', JSON.stringify({
        session: this.sessionData,
        events: this.events
      }))
    }
  }
}

// å…¨å±€åˆå§‹åŒ–
const analytics = new UserBehaviorAnalytics()

// é¡µé¢å¸è½½æ—¶å‘é€æ•°æ®
window.addEventListener('beforeunload', () => {
  analytics.onPageUnload()
})
```

### 3. A/Bæµ‹è¯•æ¡†æ¶
```javascript
// A/Bæµ‹è¯•é…ç½®
class ABTestingService {
  constructor() {
    this.tests = new Map()
    this.userVariants = new Map()
    this.loadActiveTests()
  }
  
  // åŠ è½½æ´»è·ƒçš„A/Bæµ‹è¯•
  async loadActiveTests() {
    try {
      const response = await fetch('/api/ab-tests/active')
      const tests = await response.json()
      
      tests.forEach(test => {
        this.tests.set(test.id, test)
      })
      
    } catch (error) {
      console.error('åŠ è½½A/Bæµ‹è¯•é…ç½®å¤±è´¥:', error)
    }
  }
  
  // è·å–ç”¨æˆ·çš„æµ‹è¯•å˜ä½“
  getUserVariant(testId) {
    if (this.userVariants.has(testId)) {
      return this.userVariants.get(testId)
    }
    
    const test = this.tests.get(testId)
    if (!test) return 'control'
    
    // åŸºäºç”¨æˆ·IDæˆ–ä¼šè¯IDç¡®å®šå˜ä½“
    const userId = this.getUserId()
    const hash = this.hashString(`${userId}_${testId}`)
    const bucket = hash % 100
    
    let variant = 'control'
    let cumulative = 0
    
    for (const [variantName, percentage] of Object.entries(test.variants)) {
      cumulative += percentage
      if (bucket < cumulative) {
        variant = variantName
        break
      }
    }
    
    this.userVariants.set(testId, variant)
    
    // è®°å½•ç”¨æˆ·åˆ†ç»„
    this.trackVariantAssignment(testId, variant)
    
    return variant
  }
  
  // è®°å½•è½¬åŒ–äº‹ä»¶
  trackConversion(testId, conversionType, value = 1) {
    const variant = this.getUserVariant(testId)
    
    analytics.recordEvent('ab_test_conversion', {
      test_id: testId,
      variant,
      conversion_type: conversionType,
      value,
      timestamp: Date.now()
    })
  }
  
  // è®°å½•å˜ä½“åˆ†é…
  trackVariantAssignment(testId, variant) {
    analytics.recordEvent('ab_test_assignment', {
      test_id: testId,
      variant,
      timestamp: Date.now()
    })
  }
  
  // å­—ç¬¦ä¸²å“ˆå¸Œå‡½æ•°
  hashString(str) {
    let hash = 0
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i)
      hash = ((hash << 5) - hash) + char
      hash = hash & hash // Convert to 32-bit integer
    }
    return Math.abs(hash)
  }
  
  // è·å–ç”¨æˆ·IDï¼ˆå¯ä»¥æ˜¯ç”¨æˆ·IDã€è®¾å¤‡IDæˆ–ä¼šè¯IDï¼‰
  getUserId() {
    return localStorage.getItem('user_id') || 
           analytics.sessionData.session_id
  }
}

// ä½¿ç”¨ç¤ºä¾‹ï¼šé¢œè‰²å¡ç‰‡å¸ƒå±€A/Bæµ‹è¯•
const abTesting = new ABTestingService()

// åœ¨é¢œè‰²åˆ—è¡¨ç»„ä»¶ä¸­ä½¿ç”¨
const colorListVariant = abTesting.getUserVariant('color_list_layout_v2')

if (colorListVariant === 'grid_large') {
  // ä½¿ç”¨å¤§ç½‘æ ¼å¸ƒå±€
  gridConfig.cardSize = 'large'
  gridConfig.columns = 4
} else if (colorListVariant === 'list_view') {
  // ä½¿ç”¨åˆ—è¡¨è§†å›¾
  gridConfig.layout = 'list'
} else {
  // æ§åˆ¶ç»„ï¼šé»˜è®¤ç½‘æ ¼
  gridConfig.cardSize = 'normal'
  gridConfig.columns = 6
}
```

## ğŸ›¡ï¸ æ•°æ®å®‰å…¨å’Œå¤‡ä»½

### 1. æ•°æ®å¤‡ä»½ç­–ç•¥
```sql
-- æ•°æ®å¤‡ä»½å­˜å‚¨è¿‡ç¨‹
DELIMITER //

CREATE PROCEDURE BackupColorData()
BEGIN
    DECLARE backup_date VARCHAR(20);
    SET backup_date = DATE_FORMAT(NOW(), '%Y%m%d_%H%i%s');
    
    -- å¤‡ä»½ä¸»é¢œè‰²è¡¨
    SET @sql = CONCAT('CREATE TABLE colors_backup_', backup_date, ' AS SELECT * FROM colors');
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    -- å¤‡ä»½æ–‡åŒ–æè¿°è¡¨
    SET @sql = CONCAT('CREATE TABLE cultural_descriptions_backup_', backup_date, ' AS SELECT * FROM color_cultural_descriptions');
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    -- å¤‡ä»½åˆ†ç±»å­—å…¸è¡¨
    SET @sql = CONCAT('CREATE TABLE dictionaries_backup_', backup_date, ' AS SELECT * FROM classification_dictionaries');
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    -- è®°å½•å¤‡ä»½ä¿¡æ¯
    INSERT INTO backup_log (backup_date, tables_backed_up, backup_size, status)
    VALUES (NOW(), 'colors,color_cultural_descriptions,classification_dictionaries', 0, 'completed');
    
END //

DELIMITER ;

-- åˆ›å»ºå¤‡ä»½æ—¥å¿—è¡¨
CREATE TABLE backup_log (
    id INT AUTO_INCREMENT PRIMARY KEY,
    backup_date TIMESTAMP,
    tables_backed_up TEXT,
    backup_size BIGINT,
    status ENUM('started', 'completed', 'failed'),
    error_message TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- è®¾ç½®å®šæ—¶å¤‡ä»½ï¼ˆæ¯å¤©å‡Œæ™¨2ç‚¹ï¼‰
-- éœ€è¦åœ¨crontabä¸­æ·»åŠ ï¼š
-- 0 2 * * * /usr/bin/mysql -u backup_user -p'password' color_db -e "CALL BackupColorData();"
```

### 2. æ•°æ®å®Œæ•´æ€§æ£€æŸ¥
```javascript
// æ•°æ®å®Œæ•´æ€§æ£€æŸ¥æœåŠ¡
class DataIntegrityService {
  async runIntegrityChecks() {
    const results = {
      timestamp: new Date().toISOString(),
      checks: [],
      summary: { passed: 0, failed: 0, warnings: 0 }
    }
    
    try {
      // 1. æ£€æŸ¥é¢œè‰²æ•°æ®å®Œæ•´æ€§
      const colorCheck = await this.checkColorDataIntegrity()
      results.checks.push(colorCheck)
      
      // 2. æ£€æŸ¥æ–‡åŒ–æè¿°å…³è”
      const culturalCheck = await this.checkCulturalDescriptionIntegrity()
      results.checks.push(culturalCheck)
      
      // 3. æ£€æŸ¥åˆ†ç±»å­—å…¸å®Œæ•´æ€§
      const dictCheck = await this.checkDictionaryIntegrity()
      results.checks.push(dictCheck)
      
      // 4. æ£€æŸ¥æ•°æ®æ ¼å¼
      const formatCheck = await this.checkDataFormats()
      results.checks.push(formatCheck)
      
      // ç»Ÿè®¡ç»“æœ
      results.checks.forEach(check => {
        if (check.status === 'passed') results.summary.passed++
        else if (check.status === 'failed') results.summary.failed++
        else results.summary.warnings++
      })
      
    } catch (error) {
      console.error('æ•°æ®å®Œæ•´æ€§æ£€æŸ¥å¤±è´¥:', error)
      results.checks.push({
        name: 'System Error',
        status: 'failed',
        message: error.message
      })
      results.summary.failed++
    }
    
    return results
  }
  
  async checkColorDataIntegrity() {
    const issues = []
    
    // æ£€æŸ¥å¿…å¡«å­—æ®µ
    const missingFields = await db.query(`
      SELECT COUNT(*) as count 
      FROM colors 
      WHERE hex IS NULL OR name_zh IS NULL OR primary_culture IS NULL
    `)
    if (missingFields[0].count > 0) {
      issues.push(`${missingFields[0].count} colors missing required fields`)
    }
    
    // æ£€æŸ¥é¢œè‰²å€¼æ ¼å¼
    const invalidHex = await db.query(`
      SELECT COUNT(*) as count 
      FROM colors 
      WHERE hex NOT REGEXP '^#[0-9A-Fa-f]{6}
    `)
    if (invalidHex[0].count > 0) {
      issues.push(`${invalidHex[0].count} colors with invalid hex format`)
    }
    
    // æ£€æŸ¥RGBå€¼èŒƒå›´
    const invalidRGB = await db.query(`
      SELECT COUNT(*) as count 
      FROM colors 
      WHERE rgb_r > 255 OR rgb_g > 255 OR rgb_b > 255 
         OR rgb_r < 0 OR rgb_g < 0 OR rgb_b < 0
    `)
    if (invalidRGB[0].count > 0) {
      issues.push(`${invalidRGB[0].count} colors with invalid RGB values`)
    }
    
    return {
      name: 'Color Data Integrity',
      status: issues.length === 0 ? 'passed' : 'failed',
      issues,
      message: issues.length === 0 ? 'All color data integrity checks passed' : `Found ${issues.length} issues`
    }
  }
  
  async checkCulturalDescriptionIntegrity() {
    const issues = []
    
    // æ£€æŸ¥å­¤ç«‹çš„æ–‡åŒ–æè¿°
    const orphaned = await db.query(`
      SELECT COUNT(*) as count
      FROM color_cultural_descriptions ccd
      LEFT JOIN colors c ON ccd.color_id = c.id
      WHERE c.id IS NULL
    `)
    if (orphaned[0].count > 0) {
      issues.push(`${orphaned[0].count} orphaned cultural descriptions`)
    }
    
    // æ£€æŸ¥has_cultural_descriptionæ ‡è¯†å‡†ç¡®æ€§
    const incorrectFlag = await db.query(`
      SELECT COUNT(*) as count
      FROM colors c
      LEFT JOIN color_cultural_descriptions ccd ON c.id = ccd.color_id
      WHERE (c.has_cultural_description = 1 AND ccd.color_id IS NULL)
         OR (c.has_cultural_description = 0 AND ccd.color_id IS NOT NULL)
    `)
    if (incorrectFlag[0].count > 0) {
      issues.push(`${incorrectFlag[0].count} colors with incorrect cultural description flag`)
    }
    
    return {
      name: 'Cultural Description Integrity',
      status: issues.length === 0 ? 'passed' : 'failed',
      issues,
      message: issues.length === 0 ? 'All cultural description integrity checks passed' : `Found ${issues.length} issues`
    }
  }
}
```

## ğŸ“– ä½¿ç”¨æŒ‡å—å’Œæœ€ä½³å®è·µ

### 1. å¼€å‘æŒ‡å—
```javascript
// é¢œè‰²æ•°æ®æ“ä½œæœ€ä½³å®è·µ

class ColorDataBestPractices {
  
  // âœ… æ­£ç¡®ï¼šåŠ è½½é¢œè‰²åˆ—è¡¨
  async loadColorsCorrectly() {
    try {
      // ä½¿ç”¨åˆ†é¡µï¼Œé¿å…ä¸€æ¬¡åŠ è½½è¿‡å¤šæ•°æ®
      const response = await colorApi.getColors({
        page: 1,
        limit: 50,
        fields: ['id', 'hex', 'name_zh', 'primary_culture', 'has_cultural_description']
      })
      
      return response.data
    } catch (error) {
      console.error('åŠ è½½é¢œè‰²å¤±è´¥:', error)
      throw error
    }
  }
  
  // âŒ é”™è¯¯ï¼šä¸€æ¬¡åŠ è½½æ‰€æœ‰æ•°æ®
  async loadColorsIncorrectly() {
    // ä¸è¦è¿™æ ·åš - ä¼šå¯¼è‡´æ€§èƒ½é—®é¢˜
    const response = await colorApi.getColors({ limit: 10000 })
    return response.data
  }
  
  // âœ… æ­£ç¡®ï¼šæŒ‰éœ€åŠ è½½æ–‡åŒ–æè¿°
  async loadCulturalDescriptionCorrectly(colorId) {
    // æ£€æŸ¥ç¼“å­˜
    if (culturalCache.has(colorId)) {
      return culturalCache.get(colorId)
    }
    
    // åªåœ¨ç”¨æˆ·çœŸæ­£éœ€è¦æ—¶åŠ è½½
    const descriptions = await colorApi.getCulturalDescriptions(colorId)
    culturalCache.set(colorId, descriptions)
    
    return descriptions
  }
  
  // âŒ é”™è¯¯ï¼šé¢„åŠ è½½æ‰€æœ‰æ–‡åŒ–æè¿°
  async loadCulturalDescriptionIncorrectly() {
    // ä¸è¦è¿™æ ·åš - æµªè´¹å¸¦å®½å’Œå†…å­˜
    const allColors = await colorApi.getColors()
    for (const color of allColors) {
      if (color.has_cultural_description) {
        await colorApi.getCulturalDescriptions(color.id)
      }
    }
  }
  
  // âœ… æ­£ç¡®ï¼šç­›é€‰å™¨ä¼˜åŒ–
  applyFiltersCorrectly(filters) {
    // ä½¿ç”¨é˜²æŠ–é¿å…é¢‘ç¹è¯·æ±‚
    const debouncedFilter = debounce(async () => {
      const response = await colorApi.getColors({
        page: 1,
        limit: 50,
        ...filters
      })
      updateColorList(response.data)
    }, 300)
    
    debouncedFilter()
  }
  
  // âœ… æ­£ç¡®ï¼šé”™è¯¯å¤„ç†
  async handleApiErrorsCorrectly() {
    try {
      const colors = await colorApi.getColors()
      return colors
    } catch (error) {
      if (error.status === 429) {
        // è¯·æ±‚è¿‡äºé¢‘ç¹ï¼Œç¨åé‡è¯•
        await new Promise(resolve => setTimeout(resolve, 1000))
        return this.handleApiErrorsCorrectly()
      } else if (error.status >= 500) {
        // æœåŠ¡å™¨é”™è¯¯ï¼Œæ˜¾ç¤ºå‹å¥½é”™è¯¯ä¿¡æ¯
        showErrorMessage('æœåŠ¡æš‚æ—¶ä¸å¯ç”¨ï¼Œè¯·ç¨åå†è¯•')
        return []
      } else {
        // å…¶ä»–é”™è¯¯
        console.error('APIè¯·æ±‚å¤±è´¥:', error)
        throw error
      }
    }
  }
}
```

### 2. æ€§èƒ½ä¼˜åŒ–æŒ‡å—
```javascript
// æ€§èƒ½ä¼˜åŒ–æœ€ä½³å®è·µ

class PerformanceOptimizations {
  
  // 1. è™šæ‹Ÿæ»šåŠ¨å®ç°
  implementVirtualScrolling() {
    return {
      setup() {
        const containerRef = ref()
        const itemHeight = 120 // æ¯ä¸ªé¢œè‰²å¡ç‰‡é«˜åº¦
        const containerHeight = ref(600)
        const scrollTop = ref(0)
        const totalItems = ref(0)
        
        const visibleRange = computed(() => {
          const start = Math.floor(scrollTop.value / itemHeight)
          const visibleCount = Math.ceil(containerHeight.value / itemHeight) + 2
          const end = Math.min(start + visibleCount, totalItems.value)
          
          return { start, end }
        })
        
        const visibleItems = computed(() => {
          const { start, end } = visibleRange.value
          return colors.value.slice(start, end).map((color, index) => ({
            ...color,
            index: start + index,
            top: (start + index) * itemHeight
          }))
        })
        
        return {
          containerRef,
          visibleItems,
          scrollTop,
          containerHeight
        }
      }
    }
  }
  
  // 2. å›¾ç‰‡æ‡’åŠ è½½
  implementLazyLoading() {
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const img = entry.target
          const src = img.dataset.src
          if (src) {
            img.src = src
            img.removeAttribute('data-src')
            observer.unobserve(img)
          }
        }
      })
    }, {
      rootMargin: '50px' // æå‰50pxå¼€å§‹åŠ è½½
    })
    
    return {
      observe(element) {
        observer.observe(element)
      },
      unobserve(element) {
        observer.unobserve(element)
      }
    }
  }
  
  // 3. é˜²æŠ–å’ŒèŠ‚æµ
  implementDebounceThrottle() {
    return {
      // æœç´¢é˜²æŠ–
      debounceSearch: debounce(async (query) => {
        const results = await colorApi.search(query)
        updateSearchResults(results)
      }, 300),
      
      // æ»šåŠ¨èŠ‚æµ
      throttleScroll: throttle((event) => {
        const scrollTop = event.target.scrollTop
        updateScrollPosition(scrollTop)
      }, 16) // ~60fps
    }
  }
  
  // 4. ç¼“å­˜ç­–ç•¥
  implementCaching() {
    const cache = new Map()
    const maxCacheSize = 1000
    
    return {
      get(key) {
        if (cache.has(key)) {
          // LRU: ç§»åˆ°æœ€å
          const value = cache.get(key)
          cache.delete(key)
          cache.set(key, value)
          return value
        }
        return null
      },
      
      set(key, value) {
        // å¦‚æœå·²å­˜åœ¨ï¼Œå…ˆåˆ é™¤
        if (cache.has(key)) {
          cache.delete(key)
        }
        
        // å¦‚æœè¶…è¿‡æœ€å¤§ç¼“å­˜å¤§å°ï¼Œåˆ é™¤æœ€æ—§çš„
        if (cache.size >= maxCacheSize) {
          const firstKey = cache.keys().next().value
          cache.delete(firstKey)
        }
        
        cache.set(key, value)
      },
      
      clear() {
        cache.clear()
      }
    }
  }
}
```

### 3. ç»´æŠ¤æŒ‡å—
```markdown
# é¢œè‰²ç³»ç»Ÿç»´æŠ¤æŒ‡å—

## æ—¥å¸¸ç»´æŠ¤ä»»åŠ¡

### æ¯æ—¥ä»»åŠ¡
- [ ] æ£€æŸ¥ç³»ç»Ÿé”™è¯¯æ—¥å¿—
- [ ] ç›‘æ§APIå“åº”æ—¶é—´
- [ ] æ£€æŸ¥ç¼“å­˜å‘½ä¸­ç‡
- [ ] æŸ¥çœ‹ç”¨æˆ·åé¦ˆå’Œé”™è¯¯æŠ¥å‘Š

### æ¯å‘¨ä»»åŠ¡
- [ ] è¿è¡Œæ•°æ®å®Œæ•´æ€§æ£€æŸ¥
- [ ] æ¸…ç†è¿‡æœŸç¼“å­˜
- [ ] åˆ†æç”¨æˆ·è¡Œä¸ºæ•°æ®
- [ ] æ›´æ–°çƒ­é—¨é¢œè‰²æ’åº

### æ¯æœˆä»»åŠ¡
- [ ] æ•°æ®åº“æ€§èƒ½ä¼˜åŒ–
- [ ] å¤‡ä»½æ•°æ®éªŒè¯
- [ ] A/Bæµ‹è¯•ç»“æœåˆ†æ
- [ ] ç³»ç»Ÿå®¹é‡è§„åˆ’

## æ•°æ®æ›´æ–°æµç¨‹

### æ·»åŠ æ–°é¢œè‰²
1. åœ¨colorsè¡¨ä¸­æ’å…¥åŸºç¡€ä¿¡æ¯
2. å¦‚æœ‰æ–‡åŒ–èƒŒæ™¯ï¼Œåœ¨color_cultural_descriptionsè¡¨ä¸­æ·»åŠ æè¿°
3. æ›´æ–°æœç´¢å…³é”®è¯
4. éªŒè¯æ•°æ®å®Œæ•´æ€§
5. æ¸…é™¤ç›¸å…³ç¼“å­˜

### æ›´æ–°æ–‡åŒ–æè¿°
1. å¤‡ä»½ç°æœ‰æ•°æ®
2. æ›´æ–°color_cultural_descriptionsè¡¨
3. è®°å½•æ›´æ”¹æ—¥å¿—
4. æ¸…é™¤æ–‡åŒ–æè¿°ç¼“å­˜
5. é€šçŸ¥å†…å®¹å›¢é˜ŸéªŒè¯

### ä¿®æ”¹åˆ†ç±»ä½“ç³»
1. è¯„ä¼°å½±å“èŒƒå›´
2. æ›´æ–°classification_dictionariesè¡¨
3. è¿è¡Œæ•°æ®è¿ç§»è„šæœ¬
4. æ›´æ–°å‰ç«¯å­—å…¸ç¼“å­˜
5. å…¨é¢æµ‹è¯•

## æ•…éšœæ’é™¤æŒ‡å—

### å¸¸è§é—®é¢˜

#### é—®é¢˜1ï¼šé¢œè‰²åˆ—è¡¨åŠ è½½ç¼“æ…¢
**å¯èƒ½åŸå› **ï¼š
- æ•°æ®åº“æŸ¥è¯¢æœªä¼˜åŒ–
- ç¼“å­˜å¤±æ•ˆ
- ç½‘ç»œè¿æ¥é—®é¢˜

**è§£å†³æ­¥éª¤**ï¼š
1. æ£€æŸ¥æ•°æ®åº“æ…¢æŸ¥è¯¢æ—¥å¿—
2. éªŒè¯ç¼“å­˜æœåŠ¡çŠ¶æ€
3. æ£€æŸ¥ç½‘ç»œå»¶è¿Ÿ
4. åˆ†æAPIå“åº”æ—¶é—´

#### é—®é¢˜2ï¼šæ–‡åŒ–æè¿°åŠ è½½å¤±è´¥
**å¯èƒ½åŸå› **ï¼š
- å¤–é”®çº¦æŸé”™è¯¯
- æƒé™é—®é¢˜
- æ•°æ®æ ¼å¼é”™è¯¯

**è§£å†³æ­¥éª¤**ï¼š
1. æ£€æŸ¥color_cultural_descriptionsè¡¨å®Œæ•´æ€§
2. éªŒè¯APIæƒé™é…ç½®
3. è¿è¡Œæ•°æ®éªŒè¯è„šæœ¬
4. æ£€æŸ¥é”™è¯¯æ—¥å¿—

#### é—®é¢˜3ï¼šæœç´¢ç»“æœä¸å‡†ç¡®
**å¯èƒ½åŸå› **ï¼š
- æœç´¢ç´¢å¼•æœªæ›´æ–°
- å…³é”®è¯é…ç½®é”™è¯¯
- æƒé‡è®¾ç½®é—®é¢˜

**è§£å†³æ­¥éª¤**ï¼š
1. é‡å»ºå…¨æ–‡æœç´¢ç´¢å¼•
2. æ£€æŸ¥search_keywordså­—æ®µ
3. è°ƒæ•´æœç´¢æƒé‡é…ç½®
4. æµ‹è¯•æœç´¢ç®—æ³•

## æ€§èƒ½ç›‘æ§

### å…³é”®æŒ‡æ ‡
- APIå“åº”æ—¶é—´ < 200ms
- ç¼“å­˜å‘½ä¸­ç‡ > 80%
- æ•°æ®åº“æŸ¥è¯¢æ—¶é—´ < 50ms
- é¡µé¢åŠ è½½æ—¶é—´ < 2s

### ç›‘æ§å·¥å…·
- æ•°æ®åº“æ€§èƒ½ç›‘æ§
- APIå“åº”æ—¶é—´ç›‘æ§
- ç¼“å­˜çŠ¶æ€ç›‘æ§
- ç”¨æˆ·ä½“éªŒç›‘æ§

### æŠ¥è­¦è®¾ç½®
- APIå“åº”æ—¶é—´ > 500ms å‘é€è­¦å‘Š
- ç¼“å­˜å‘½ä¸­ç‡ < 70% å‘é€è­¦å‘Š
- é”™è¯¯ç‡ > 1% å‘é€ç´§æ€¥æŠ¥è­¦
- æ•°æ®åº“è¿æ¥æ•° > 80% å‘é€è­¦å‘Š
```

## ğŸ¯ æ€»ç»“

æœ¬æ–‡æ¡£æä¾›äº†Fashion Coloré¡¹ç›®å®Œæ•´çš„é¢œè‰²æ•°æ®ç»“æ„è®¾è®¡ï¼ŒåŒ…æ‹¬ï¼š

### ğŸ—ï¸ æ ¸å¿ƒæ¶æ„
- **åŒè¡¨è®¾è®¡**ï¼šä¸»é¢œè‰²è¡¨ + æ–‡åŒ–æè¿°è¡¨åˆ†ç¦»
- **æ€§èƒ½ä¼˜å…ˆ**ï¼šæ‡’åŠ è½½ + ç¼“å­˜ä¼˜åŒ–
- **å¤šæ–‡åŒ–æ”¯æŒ**ï¼šä¸€ä¸ªé¢œè‰²å¤šç§æ–‡åŒ–èƒŒæ™¯
- **åˆ†ç±»ç®€åŒ–**ï¼šè§£å†³åŸæœ‰æ ‡ç­¾é‡åˆé—®é¢˜

### ğŸ“Š æ•°æ®ç‰¹æ€§
- **å®Œæ•´æ€§**ï¼šåŒ…å«RGBã€HSLã€Labç­‰å®Œæ•´è‰²å½©æ•°æ®
- **æ‰©å±•æ€§**ï¼šæ”¯æŒæ–°å¢æ–‡åŒ–æ ‡ç­¾å’Œæè¿°
- **æœç´¢ä¼˜åŒ–**ï¼šå…¨æ–‡æœç´¢ + æƒé‡ç®—æ³•
- **ç”¨æˆ·ä½“éªŒ**ï¼šå“åº”å¼åŠ è½½ + é”™è¯¯å¤„ç†

### ğŸ”§ æŠ€æœ¯å®ç°
- **APIè®¾è®¡**ï¼šRESTfulæ¥å£ + å“åº”å¼å­—æ®µ
- **ç¼“å­˜ç­–ç•¥**ï¼šRediså¤šå±‚ç¼“å­˜
- **ç›‘æ§åˆ†æ**ï¼šæ€§èƒ½ç›‘æ§ + ç”¨æˆ·è¡Œä¸ºåˆ†æ
- **A/Bæµ‹è¯•**ï¼šå®Œæ•´çš„å®éªŒæ¡†æ¶

### ğŸ›¡ï¸ è¿ç»´ä¿éšœ
- **æ•°æ®å®‰å…¨**ï¼šå®šæ—¶å¤‡ä»½ + å®Œæ•´æ€§æ£€æŸ¥
- **æ€§èƒ½ä¼˜åŒ–**ï¼šè™šæ‹Ÿæ»šåŠ¨ + æ‡’åŠ è½½
- **æ•…éšœå¤„ç†**ï¼šè¯¦ç»†çš„æ•…éšœæ’é™¤æŒ‡å—
- **ç»´æŠ¤æµç¨‹**ï¼šæ ‡å‡†åŒ–çš„ç»´æŠ¤å’Œæ›´æ–°æµç¨‹

è¿™ä¸ªè®¾è®¡æ—¢æ»¡è¶³äº†å½“å‰éœ€æ±‚ï¼Œåˆä¸ºæœªæ¥æ‰©å±•ç•™å‡ºäº†ç©ºé—´ï¼Œæ˜¯ä¸€ä¸ªå®Œæ•´ã€å¯ç»´æŠ¤ã€é«˜æ€§èƒ½çš„é¢œè‰²ç®¡ç†ç³»ç»Ÿè§£å†³æ–¹æ¡ˆã€‚